安装vmtool的目录
In which directory do you want to install the binary files? 
[/usr/bin] /usr/bin
注意/opt中包含该文件
What is the directory that contains the init directories (rc0.d/ to rc6.d/)? 
[/etc] /etc
What is the directory that contains the init scripts? 
[/etc/init.d] 
In which directory do you want to install the daemon files? 
[/usr/sbin] 
In which directory do you want to install the library files? 
[/usr/lib/vmware-tools] 
In which directory do you want to install the common agent library files? 
[/usr/lib] /usr/lib
In which directory do you want to install the common agent transient files? 
[/var/lib] /var/lib
In which directory do you want to install the documentation files? 
[/usr/share/doc/vmware-tools] 
-------------------------------------chapter0:linux操作系统入门-------------------------------------
1.鸟哥的linux私房菜：基础学习、服务器架设篇幅
2.ubuntu每年两个版本 4月份 10月份   lts版本—long term support 维护时间长，建议选择
3.虚拟软件 vmware      virtual box      parallel box(mac)
4.搜索窗口中gnome-te打开终端  ctrl+ait+t也可以
ctrl shift +放大 ctrl - 缩小窗口
5.最高权限用户root
6软件更新安装 apt-get 
step1 sudo apt-get update下载软件列表，形成本地数据库
step2 sudo apt-get upgrade upgrade根据下载的软件列表对比本地的软件，并更新所有的软件
7.镜像源的选择  教育网、商业网
配置信息 nano /etc/apt/sources.list  ctrl+a回到命令行的开头 ctrl+e回到结尾 ctrl+u删除 
histoy查询历史记录 !132执行敲击的132行命令
8.数据缓冲的清除
下载软件包存在的位置 cd /var/cache
打开列表ls
进入cd archives  包含大量的deb文件（linux）     du -sh 可以查看文件大小
使用rm fr * 或者sudo rm 或者 sudo apt-get clean删除
9.sudoers文件的设置
打开文件more /etc/sudoers
使用visudo调用编辑器对文件编辑sudo visudo ----会写入临时文件并检测语法错误
下次使用sudo就没有密码提示了
# User privilege specification
root    ALL=(ALL:ALL) ALL
# Allow members of group sudo to execute any command
%sudo   ALL=(ALL:ALL) ALL
# Members of the admin group may gain root privileges
%admin ALL=(ALL) ALL
%adm ALL=(ALL) NOPASSWD:ALL
10.软件安装
sudo apt-get install mysql
需要找到mysql对应的软件包的名字：
列表数据库中寻找关键字apt-cache search mysql 然后进行安装
11.软件的删除
使用dpkg可以安装deb的包，下载软件以及依赖的包 不会考虑包的关联性
dpkg -l查看安装的包
sudo apt-get remove tree删除软件包
sudo apt-get remove –purge tree删除软件包及其配置文件
12.使用dpkg -L tree命令查看软件包安装的文件以及所在的文件
apt-get属于系统层次的软件包管理，单独删除文件也可以删除这个软件，但是会与系统层次对应不上，一般使用sudo apt-get remove 进行删除
-------------------------------------chapter1:首次登陆与在线求助-------------------------------------
1.系统会创建很多的用户，id独一，密码匹配即可
2.远程连接通过以太网卡、终端接口或者直接使用某台unix的控制台指定unix主机的地址进行远程登陆
ssh服务器  secure shell
telnetd（deamon）和telnet 相对应
3.成功登陆之后就可以在命令行中进行操作了
4.logout 或者exit或者 ctrl d退出系统
5.关闭系统：shutdown -h now 或halt 或 init 0
6.重启系统：reboot或者init 6
一般使用普通用户来进行操作，不应该用root用户
7.passwd命令来修改密码
8.shell：提供到linux操作系统的界面以方便运行程序，事实上，shell只不过是另外一个linux操作系统程序而已。是一个命令解释器，是操作系统的一个整体组成部分。用户shell的配置位置/etc/passwd文件中每条记录的最后一个字段
root:x:0:0:root:/root:/bin/bash
用户：密码：uesrid：gorupid：户描述：家目录：当前目录下的shell
9.linux所有应用程序都有全局配置文件/etc/firefox/config—对所有使用用户都生效和个人配置文件
/home/tracer家目录下
个人配置信息会覆盖全局配置信息
10.shell->bash系统使用更新过的bashell
基于curse的shell：文本 mc—文本字符的形式
图形化shell：图形界面类似于资源管理器
ash：袖珍，比较小
最复杂的shell：z-shell
-----------------------------------------process-------------------------------------------------
11.ps命令查询当前用户的运行程序process，每一个程序都有一个id，command代表具体的应用是什么
ps ax命令查询所有用户的运行程序
进程号代表数字—唯一一个进程号，占用进程可能没有退出，进程数字号就可能被跳过
12.在后台运行程序，在内存中进行，但是不占用命令行的执行控制权。一般对巨型文件排序或者对子目录或者其他类型的文件系统进行搜索等操作都可以放在后台进行。
Command & 程序在后台执行
nohup Command &在后台运行程序的方式：哪怕本地服务器退出，但是进程一直存在，程序会议之运行，hup--信号
trap -l命令：列出当前系统中所有支持的信号
13.kill pid杀掉一个进程 后台现实terminated，正常结束是down
kill -9 pid杀掉一个顽固的进程
有时候web server启动会产生一个主进程，主进程会产生子进程，进程id号无法判断主次
killall httpd杀掉该程序引发的所有进程
--------------------------------------------作业控制---------------------------------------------
14.jobs显示正在执行的进程
15.fg %pid  把后台的程序调到前台进行执行（foreground）
ctrl c 把当前任务切换到后台并处于停止的状态（sigint信号）
ctrl \ （sigout信号）
ctrl z 挂起前台作业
16.bg %pid把后台的程序恢复执行（background）
17.kill %pid杀掉进程
--------------------------------------------重定向和管道------------------------------------------
18.重定向：改变命令的标准输入和标准输出
< 标准输入重定向   ./a.out < test(c程序中的应用)
> 标准输出重定向（文件、打印机等等） 覆盖重定向
more查看文件内容
>>追加重定向，追加到文件的后面
wordpress个人博客系统
19：管道pipe:将前一个命令的标准输出直接连接到后一个命令的标准输入上
例子：
wc wordcount统计字符 3行3个单词6个字符
wc < aa统计aa文件的内容
ps ax  | wc   相当于把ps ax输出给到wc—管道
grep usr 选择包含usr的内容
ps ax  |  grep usr | wc 
ps ax  |  grep usr | wc  -l只显示行数 
20查看命令的参数 man ls
--------------------------------------------shell脚本编成------------------------------------------
data显示日期
cal显示当前的月份
ls;data;cal ;代表分割命令
编写脚本nano t.sh
ls
data
cal
给文件加上指定权限chmod +x t.sh
运行脚本 ./t.sh
--------------------------------------------linux命令的形式-----------------------------------------
gnome-terminal启动终端
command [-option] parameter1 parameter2     -字母  --单词一般使用短格式
命令、选项、参数间使用空格进行分割
命令过长使用续行符 \使输入 延续到下一行中
linux中大小写是区分的
locale列出当前系统所有的设置，设置为utf-8后就不会出现乱码问题
修改语系：
LANG=en_US.utf8
export LC_ALL=en_US.utf8
如果可能，永远选择utf-8编码
bc自带的计算器—任何精度  bc -l加载相关的库
scale=2;3/8
脚本中要进行计算：  echo”1.5+3” | bc      echo”obase=2;127” | bc  输出二进制
apcalc计算器  calc打开
常用热键：
tab补全命令
ctrl c 终止任务
ctrl d end of file/input 常见动作为退出
shift pgup/pgdn 翻页查看过往输出
--------------------------------------------在线求助info和man-----------------------------------------
1.通用模式：  --help  -h查看命令
2.man command 查看手册页 
手册系统中的全部资料根据功能划分会存储在不同的目录pwd（1-用户在shell中可以操作的指令或者执行的文件） FOPEN（3—一些常用的函数或者函数库）
/user/share/man目录是安装的手册页面的存放目录man1-man8,其他目录是其他国家的目录ru俄文de德语等等
/user/share/man/man1  包含手册，具有特定的编写语言
~代表家目录，默认情况下除了家默认是没有读写权限的
move ../XX . 移动上一个目录的文件到当前目录
gzip -d  XX.gz进行解压操作
3.man的所与配置信息，可以得知这些手册资料在系统中的具体存放位置
/etc中存储具体的配置文件 config文件
/etc/manpath.config手册配置信息
4.相关命令
whatis 等价  man -f
apropos 等价man -k
5.info系统：纯文本的联结系统，查看特定的信息，www页面替代了他，此处不讲解
6.联机帮助文件
/usr/share/doc目录
每package存放一个目录
7.正确开关机器：
shutdown -h now
shutdown -h 10 “I will shut down”
shutdown 一分钟后关机
shutdown -c 取消关机
reboot/halt/poweroff
--------------------------------------------unix文件系统-----------------------------------------
1.unix文件系统简介
linux的目录划分遵循的标准：
Linux standard base lsb
filesystem hierarchy standard fhs
目录文件、普通文件、设备文件、符号链接
设备文件代表连接在系统上的物理设备 键盘-字符设备、块设备—磁盘
符号链接指向另一个文件的文件（类似于windows下的快捷方式）
tracer@tracerX:/dev$ ls h*
hidraw0  hpet  hwrng
hugepages:
tracer@tracerX:/dev$ ls sd*     
sda  sda1  sda2  sda5
sda表示disk,是第一个磁盘
sda1表示第一个磁盘的第一个分区
2.用户主目录（登陆目录、其实目录、家目录）/home 登陆后自动位于主目录
可以通过/etc/passwd来查看
很多系统使用～来代表用户主目录
可以使用echo $HOME 显示用户家目录
可以使用pwd来显示当前的目录 print working directory
3.路径：
绝对路径 /是根目录 
相对路径是当前目录到此文件的路径：  .当前目录  ..父目录
back-slash /   unix
forward-slash \  windows
4.目录和文件的命名规则
除去/和空字符（\0）外都合法；unix是大小写敏感的；避免使用+ -作为开头；创建特殊字符时加引号””或者./”XXXX”
5.目录解释
​
添加图片注释，不超过 140 字（可选）
/bin
	
存放二进制可执行文件(ls,cat,mkdir等)，单人模式下常用命令一般都在这里。cat、chmod
/etc不变的、不可分享的
	
存放系统管理和配置文件
/home
	
存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示
/usrunixsoftwareresource与软件安装和执行有关
	
用于存放系统应用程序，比较重要的目录/usr/local 本地系统管理员软件安装目录（安装系统级的应用）。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录。usrlocal管理员安装自己下载的软件/usr/x11r6 存放x window的目录/usr/bin 众多的应用程序  /usr/sbin 超级用户的一些管理程序  /usr/doc linux文档  /usr/include linux下开发和编译应用程序所需要的头文件   c++头文件默认存在的目录/usr/lib 常用的动态链接库和软件包的配置文件  /usr/man 帮助文档  /usr/src 源代码，linux内核的源代码就放在/usr/src/linux里  /usr/local/bin 本地增加的命令  /usr/local/lib 本地增加的库
/optoptional可能有可能没有第三方软件
	
额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里。
/proc
	
虚拟文件系统目录，是系统内存的映射。本身不占用磁盘空间。可直接访问这个目录来获取系统信息。
/root
	
超级用户（系统管理员）的主目录（特权阶级^o^）
/sbin
	
存放二进制可执行文件，只有root才能访问。开机、修复、还原文件系统时使用这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等。
/dev
	
用于存放设备文件。设备与接口文件，访问某个文件相当于u访问了某一个设备
/mnt
	
系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统。
/boot不变的不可分享
	
存放用于系统引导时使用的各种文件，存放开机时会使用的文件
/lib
	
存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。
/tmp
	
用于存放各种临时文件，是公用的临时文件存储点。系统重启会清空所有内容
/var与系统运行有关程序不可分享邮件、新闻可分享
	
用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等。/Log存放应用的日志/lib数据文件存放目录/lock存放应用的加锁文件，避免单一应用同时启动多个进程/spoil存放一个队列，存储完成之后被清除
/media
	
可移除设备在这个目录下 dvd usb disk floppy adrom
/mnt
	
mount其他设备时使用，比方说第二块硬盘
/lib
	
存放开机时会使用的函数库 /lib/module中存放核心驱动模块
/lost+found
	
这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里 ext2/3/4文件系统格式，类似于chkdsk找回的文件
目录分类：
可执行的-可以分享给其他系统的，节省空间
不可分享的-只与自身机器有关
不变的-函数库、文件说明文件等的呢个
可变的：登陆文件、用户接收的新闻组件
--------------------------------------------linux文件权限-----------------------------------------------------------
解决permission denied问题
1.用户和群组
/etc/passwd存放用户信息
/etc/shadow存放用户密码信息
/etc/group存放用户组信息
tracer:x:1000:1000:tracer,,,:/home/tracer:/bin/bash
1000:1000:  usrid:groupid
查看id可以使用id命令
用户id=1000(tracer) 组id=1000(tracer) 组=1000(tracer),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),132(lxd),133(sambashare)
把创建的第一个用户加入到很多组中，方便进一步操作
/etc/group表示每行存在一个用户组
/etc/shadow存放密码是加密过的
tracer:$6$ikYSIk25b2s2JmsX$yix0ophkBhXq9Z.vV8X7L7I2gnZPDI4iV0F/Td6OUcw2gGjeg6H4
qREhD6aqF4.pmHuK9ORY8FIjGnP9S78xk/:19042:0:99999:7:::
systemd-coredump:!!:19042::::::
2.文件权限
2.1文件属性
ls -l以列表输出
drwxr-xr-x 18 tracer（用户） tracer(组) 4096 2月  20 12:23 tracer
文件权限 文件连接数 文件拥有者 文件所属组 文件大小 文件时间 文件名称
(1.1)文件权限：
d-目录
- 普通文件
l 链接文件
b 块设备文件--磁盘
c 字符设备文件—键盘
p 管道文件
s socket文件
（1.2）其他9个字符rwxr-xr-x  三位一组
r 读 w 写 x 执行 无相应的权限使用-代替
第一组代表文件拥有着具备的权限
第二组代表文件拥有着同组用户拥有的权限
第三组其他人拥有的权限
touch 创建文件
sudo chown young：root test1 修改用户的组  
2.2文件权限的修改命令
chmod

    基于符号修改：u g o
    chmod u+x test
    chmod u-x,g+w test
    chmod u=rwx,g=w test
    chmod a-x test  (a代表ugo)
    使用数字方式修改权限--常用

设置1 不设置代表0 100010010
chmod 755 test
2.3修改文件拥有者和所属的组
文件拥有者sudo chown someuser test
所属的组sudo chgrp somegroup test
同时修改sudo chown someuser: somegroup test
全部修改文件夹（R-递归）sudo chown -R someuser: somegroup test
2.4文件权限的含义
文件分为目录、文件
普通文件
r-对应用户可以读取相关内容 cp/cat/more/less
w-对应用户可以编辑新增修改文件 nana/vi/ed
x- 文件具有被系统执行的权限
目录：
r-具有读取列表结构的权限  ls
w-用户可以修改目录的结构列表  创建或者删除文件和目录（与文件权限无关）
x -代表用户是否可以进入这个目录
touch命令创建空文件，可以进行测试
mkdir创建空的目录
3.文件与目录的默认权限问题
umask 0022 022决定了文件目录的默认权限
file 666-umask   rw-r--r--
dir  777-umask   rwxr-xr-x
umask的值也可以设定 umask 0002 更加友好
umask -S 符号显示符号表示
4.文件隐藏属性 umask的第一个bit

    set uid
    umask 0002 对应三个bit
    定义文件位置 which passwd
    查看属性ls -l /usr/bin/passwd
    rwsr-xr-x rws=set uid之后将x显示为s
    chmod 4700 test rws  最高比特相当于set usrid-4
    设置userid的用途：程序运行后具有了owner的权限，此时具有了所属的权限，解决了password的问题，仅仅在程序中有效
    chmod u+s test
    0 b1-set uid b2-set gid b3
    set gid

locate test 从当前已经更新完的数据库中查找包含关键字的记录
updatedb—更新数据库 存储所有文件名，更新动作不是实时的
set gid作用：仅仅对二进制文件有效，执行时刻获得当前组的权限，目的是获取组中某个文件的功能
对于目录也可以设置setgid权限,所有进入这个目录的用户创建的文件都属于同一个组
chmod 2700 test
chmod g+s test
（3）sticky bit
1986年引入目前仅对目录有效 /tmp目录
drwxrwxrwt  21 root root      4096 2月  21 18:34 tmp
有可执行权限t    没有可执行权限T
被一个用户破解后，只能使用该权限，他启动完成后会创建临时文件，用户再次目录下创建的文件仅有目录拥有者、自己、root才有权利删除这个文件
chmod 1777 test
chmod +t test
5.文件隐藏属性 attribute ext2 ext3 ext4 –主流的文件系统 windows-ntfs，fat32
5.1 chattr [+-=] [Asacdistu] 文件或者目录名称
参数
	
含义
A
	
设置A属性后，若你访问此文件或目录时，它的访问时间atime不会被修改，可避免I/O较慢的机器过度访问磁盘。这对速度较慢的计算机有帮助。目前较多程序已经noatime，可以不需要加这个字母
S
	
一般文件是异步写入磁盘，加上S属性后，文件将同步写入磁盘
a
	
当设置a后，文件只能增加数据，既不能删除也不能修改数据，只有root才能设置这个属性
c
	
设置c属性后，会自动将文件压缩，在读取时自动解压缩
d
	
当dump程序执行时，设置d属性将可使改文件或目录不被dump备份
i
	
i属性可使文件不能被删除、改名，设置连接也无法写入或添加数据。对于系统安全性有很大帮助。只有root能设置此属性。
s
	
当文件设置s属性时，如果文件被删除，将从硬盘彻底删除
u
	
与s相反，当文件设置u属性时，文件删除后数据内容还存在磁盘，可以使用来找回该文件

    A

Stat 可以查看文件的状态
  文件：bin -> usr/bin
  大小：7         块：0          IO 块：4096   符号链接
设备：805h/2053dInode：13          硬链接：1
权限：(0777/lrwxrwxrwx)  Uid：(    0/    root)   Gid：(    0/    root)
access最近访问：2022-02-21 02:49:54.459361389 +0800(atime最后一次访问的时间)
modify最近更改：2022-02-19 20:49:58.504009079 +0800（修改内容）
change最近改动：2022-02-19 20:49:58.504009079 +0800（修改inode--权限、内容）
创建时间：-
（2）lsattr显示文件隐藏属性
-a 将隐藏文件的属性也列出来
-d 接的是目录，列出目录本身的属性而非目录内的文件名
-R 连同子目录的数据也列出来 
-------------------------------------chacpter2：linux文件与目录管理-----------------------------------------
1.目录管理与文件
ls -a显示所有文件 文件名第一个字符.就是隐藏文件 .文件为配置文件或者目录等文件，实际上可以不看到他
la 是ls -a的别名，可以通过alias查看所有命令的别名
mkfifo myfifo创建管道文件 |管道文件   *执行文件  /目录文件 不加-普通文件 
ls -F显示文件类型
ls -h 以gb/kb显示文件容量
2.切换目录cd
cd 回到家目录 ～
cd – 最近访问的两个目录进行切换
3.pwd显示当前的工作目录   bash内置了很多命令，需要查看的话可以用help命令
执行命令需要区分是内置命令还是磁盘上的可执行文件提供的
which pwd 也是存在的
4.mkdir建立目录
mkdir -p 4/5/6/7 创建多层目录
mkdir -p {a,b} 一次生成多个目录
mkdir -p {a,b}/{c,d}/{e,f} 以组合数形成目录
mkdir -m 711 test创建制定权限的目录
5.rmdir删除目录
rmdir -p 4/5/6/7 
当目录中存在隐藏文件时，无法直接删除 
rm -fr 可以强制删除目录
6.rm删除文件
rm filename 删除文件
rm -i 交互式操作，安全性可靠
rm -r 带目录删除
rm -rf强制带目录删除
7.硬链接与符号链接ln—快捷方式
（1）硬链接
ctrl o保存 ctrl x退出
ln test1 test2 硬链接方式 ：：test1是一份内容，在目录表中是两份内容，test2是一个链接，指向磁盘中同一位置 ls -li查看文件在磁盘中的位置
删除文件 unlink减少连接数 不是remove delete等命令
对于文件是硬链接数，目录是其中的子目录数
（2）符号链接
ln -s test1 test2  test2→test1 编辑test2也是编辑test1的内容 内斯与快捷方式
但是test1文件内容大小是文件名的数目
8.cp拷贝文件
cp test2 test1 生成test1文件，把test2文件拷贝过去；test1也可以是目录
cp -R带目录拷贝
cp -i  交互方式 避免覆盖
cp -a 相当于-pPR 保留所有权限
cp -l 硬链接方式拷贝 类似于ln命令
cp -s 符号链接方式拷贝
cp -f force强制的方式
9.mv移动文件或者目录
mv sourcefile targetfile文件改名
mv sourcefile1 sourcefile2 directory
-f强制覆盖
-i互动模式
-u目标位置存在，source新才会更新
10.basename 获取文件名称
basename /home/test  输出文件名test
basename /home/test.c .c 输出test，去除后缀
basename -s .c /home/test.c 输出test  -s指定后缀是什么
basename -a 批量处理
写脚本会用到
11.dirname—获取目录名称
dirname /home/test  输出文件名/home
12.文件内容查询
（1）cat （concatenate 单词 连接文件内容和当前输出链接）
cat -n 为每行信息添加行号
cat -A显示特殊字符
cat  > newfile 一种创建新文件的方法—可以编辑一个文件 停止输入ctrl d
-b 仅仅对非空白行作出行号显示
（2）more/less分屏显示文件内容
h或？获得帮助
空格翻页
enter下一行
/字符串 向后搜索字符串
？字符串 向前搜索字符串
n 重复前一个动作
N 反向重复前一个动作
:f 显示文件名以及目前显示的函数
q退出
b前向翻页
g调至第一行
G跳到最后一行
（3）tac 反向查看文件内容
（4）nl [-bnw] file 添加行号显示
-b a显示空行
-b t不显示空行
-n ln屏幕左方显示行号
-n rn字段最右边显示行号 不补0填充字宽
-n rz字段最右边显示行号 补0填充字宽
-w 行号字段占用的字数
nl -w 4 -n rz myfile
（5）head -5 file 显示前几行
（6）tail -5 file显示后几行
tail +n number file 查看文件number行以后的内容
tail -n number file 查看文件最后number行
tail -f file 持续查看文件的最后几行-持续监控服务日志
（7）od命令查看文件内容 使用某种进制
od -t TYPE file
a 默认字符
c -ascii码查看
o 八进制
x 十六进制
f浮点数
d 十进制
oCc 八进制 ascii字符对照
（8）touch 创建新文件或者更新时间辍
touch 文件在进行编译即可
-a 修订 accesstime
-m 修改mtime
（9）stat 命令
(display file or file system status)
查看文件状态信息，参数很多 查看文档man stat
（10）file得知文件类型 –根据文件头部来分析文件信息
determine file type
docx – 文件头pk
zip -文件头pk
查看文件头 hexedit 用hex文件显示文件头部信息
(11)which 查看某个命令的位置
which passwd
which -a passwd 列出所有的位置
（12）whereis 查找文件，给出文件目录和手册页面
-l 列出whereis会查询的目录
-b 只查找二进制文件
（13）loacte / updatedb 基于数据库进行文件查找
-i 不区分大小
locate -S 列出数据库的信息
(14)find—按照各种规则查找指定文件并在其上执行所需要的操作
find [path] [option] [action]
find查找选项更加自由，同时能对文件进行删除
find -name *.zip
find -size [+-]size 查找比size大小的文件
find -perm -0744 包含0744权限的文件
find -perm /0744 0744的子集权限的文件
find / -name “*passwd”  查找所有的文件
find / -name “*passwd” -exec ls -l {} \ 查找文件并执行相关的动作
{}表示*.*代表查找到的所有内容
\表示程序的结尾，没有是不行的
(15)diff命令 显示两个文件的区别
diff hello.c hello_new.c
以hello.c为基准进行对比
2a34 添加第3，4行到第2行
5c7 第5行更换为第7行的内容
diff -u hello.c hello_new.c -1,7+1,9 1到7行对应1到9行
发现区别后可以将区别进行存储：
diff -u hello.c hello_new.c > hello_new.patch
patch < hello_new.patch 相当于给hello.c打了补丁，进行了版本升级
（16）wc统计指定文件中的字符、词和行的数量，可以同时处理多个文件
9 14 11 hello.c
-l 统计行数
-w 统计单词数
-c 统计字节数
-m 统计字符数
（17）size 查看目标文件，代码文件的大小
13.path环境变量,存放执行命令是搜索的目录列表
echo $PATH –存放路径列表
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
写一个command时是从path路径中依次去查找，查找到就会执行
path中没有当前路径：为了安全起见运行时使用./command
添加当前路径的方式 PATH=.:$PATH;export PATH
14.bash小知识
（1）bash运行方式
login vs Non-login
显示当前的shell echo $SHELL 显示第几重shell echo $SHLVL
再启动一个bash 就进入第二重
interactive vs Non-interactive 
非交互式shell ： bash =c “data”
（2）bash命令行参数 bash是shell 不是bshell
-c string 执行字符串的命令
-i interactive
-l 让bash如同登陆一样工作
（3）bash运行脚本
bash[-x] filename.sh
系统shell中如何查看命令运行的返回值echo $？
脚本运行成功或者没有指令，返回值都是0
bash -x 脚本
执行时会显示对应执行的指令
（4）bash配置文件
login：执行/etc/profile,进行全局的配置文件(系统配置文件，设置所有用户的环境)，接着查找~/.bash_profile,~/.bash_login.~/.profile，执行第一个存在并可读的配置文件，进行用户的配置文件
用户配置的修改可以覆盖全局配置的修改
non-login shell 执行/etc/bash.bashrc 使用方法：开一个窗口时修改该文件用于执行
退出时 ~/.bash_logout
补充1：：“non-login shell 场景: 当用户直接在shell窗口中通过bash以及登录图形界面后打开的shell(CTRL+ALT+T)。”
补充2：：判断 Shell 是否为登录式也非常简单，只需执行shopt login_shell即可，值为on表示为登录式，off为非登录式。
shopt 命令用来查看或设置 Shell 中的行为选项，这些选项可以增强 Shell 的易用性。
补充3：：1) 通过 Linux 控制台（不是桌面环境自带的终端）或者 ssh 登录 Shell 时（这才是正常登录方式），为交互式的登录 Shell。2) 执行 bash 命令时默认是非登录的，增加--login选项（简写为-l）后变成登录式。 3) 使用由()包围的组命令或者命令替换进入子 Shell 时，子 Shell 会继承父 Shell 的交互和登录属性。 4) ssh 执行远程命令，但不登录时，为非交互非登录式。 5) 在 Linux 桌面环境下打开终端时，为交互式的非登录 Shell。 
（5）-c的补充
sudo ls /root/ > /root/ouput.txt
重定向可以 sudo只针对第一部分有效，生成结果重定向时不被sudo控制
-c string 执行字符串的命令
sudo bash -c “ls /root/ > /root/ouput.txt” 新shell有sudo的权限，没有任何问题
或者把命令写入脚本 sudo bash XX.sh 进行执行
或者sudo -s 用sudo启动一个shell 这个命令行有所有权限
15.常用命令
whatis ls  查询手册页-解释命令
which ls  查询文件目录
whereis ls 文件以及手册位置
top查看系统的情况 ？查看各种设定
top - 18:30:38 up 1 day,  7:08,  1 user,  load average: 0.50, 0.30, 0.21
短期、中期、长期的系统负载
atop安装也可以查看相关信息
iotop查看进程的操作
gcal gnu图形界面的cal
free显示当前的内存和交换分区的使用情况
who显示当前系统中的登陆用户
w查看登陆用户的具体信息
last显示最近用户登录的历史信息
nohup command使得运行的命令忽略sighup信号
nice调整运行进程的优先级别 -n 将优先级增加n  从-20到19
uname显示系统的相关信息 uname -a 显示all information
16.软件包管理相关命令
（1）apt是一个综合的命令
apt-get install remove update upgrade 
apt-cache search pkg-name 搜索软件包
aptitude是apt命令的一个字符环境下的前端，利用curse技术为用户提供了一个好用的多的用户界面
（2）dpkg安装deb包
dpkg [option] action
deb是debian linux的安装格式，跟red hat 的rpm非常相似
dpkg 是debian package的意思，为debian为专门开发的套间管理系统
-i 单独安装，通常时手动下载的文件
-c 列出pkg.deb的内容
-L 显示包内容
（3）rpm （redhat package manager）软件包管理系统
（4）yum （wellow dog updater）包管理系统
（5）源代码安装 解压，进目录，运行.comfig，make，install
17.用户沟通的一些命令
（1）mail收发邮件
（2）talk other user  ctrlD退出
（3）write user message
（4）wall 向所有用户发送信息
18.一些相关的网络命令
（1．hostname 命令
（1）一般格式：hostname   [选项]   [主机名]
（2）说明：显示或设置系统的主机名；如果无任何选项和主机名，则用于显示系统的主机名。
（3）举例：显示本机的主机名。
[root@localhost/root]#hostname
localhost.localdomain
（2．ping 命令
（1）一般格式：ping   [选项] 主机名（或IP地址）
（2）说明：测试本主机和目标主机的连通性。Ping命令使用ICMP协议，向网络主机发送ECHO_ REQUEST数据包，希望获得主机的ICMP ECHOP _RESPONSE应答数据包，以判断和网络主机之间的连接情况。
（3）举例：测试本机与 IP 地址为 202.199.186.26的机器是否连通, 发送10个包, 每个包间隔为2秒。
[root@localhost /root]#ping   -c 10 –i 2   202.199.186.26
（3．host 命令
（1）一般格式：host    [选项]   主机名或 IP 地址
（2）说明：该命令用于 IP 地址查找，它有两种功能：一个用来查找指定 IP 的网络域名，另一个是用来查找指定域名的 IP 地址。
（3）举例：查找202.199.184.1所对应域名。
[root@localhost/root]#host 202.199.184.1
133.134.96.202.in_addr.arpa.domain   name    pointer   ns.szptt.net.cn.
（4. ifconfig 命令
（1）一般格式：ifconfig   网卡号   [选项][IP地址]
（2）说明：该命令用于配置常驻内存的网络界面，如果不指定任何选项，则显示当前网络状态。
（3）举例：显示当前主机的网卡信息。
[root@localhost /root]#ifconfig
（5．traceroute 命令
（1）一般格式：traceroute   目标主机名或 IP 地址
（2）说明：该命令显示本机到达目标主机的路由路径。Internet 是一个由网关连接起来的子网集合，要跟踪一个数据包所经过的路程是很困难的事情。Traceroute 利用 IP 协议，通过数据包的TTL 部分获得各个网关信息。
（3）举例：显示到 www.sina.com 路径。
[root@localhost /root]#tracerout  www.sina.com
（6．netstat 命令
（1）一般格式：netstat   [选项]
（2）说明：该命令用来显示各种各样的与网络相关的状态信息，主要包括：查看网络的连接状态、检查接口的配置信息、检查路由表、取得统计信息。
（3）举例：显示网卡的统计数。
[root@localhost /root]#netstat –i
（7．finger 命令
（1）一般格式：finger [选项]   [user@host..]
（2）说明：该命令用于显示主机系统中用户的信息。
（3）举例：显示用户 fedora 的详细信息。
[root@localhost /root]#finger –s fedora
slrum实时网络负载检测工具
tcpdump写出指定网络接口上的通信数据
ping向指定的主机发送icmp协议的echo——request数据报并测量其响应时间
traceroute在ip层跟并输出数据包的路由过程
curl下载指定的url到本地
wget 非交互式的url下载工具，通常用于镜像整个网站到本地
wireshark网络分析仪，甚至扩展到了蓝牙和usb接口上
mtr网络诊断工具，整合了traceroute和ping
lynx文本模式的浏览器
w3m文本模式浏览器，同时还可以作为paper使用
lftp 文本模式ftp客户端，支持多种文件传输协议，甚至包括bittorrent
gftp ftp的图形客户端
ssh安全的远程登陆客户端
19.just for fun命令

    cowsay cowthink
    cowsay “hello”
    figlet
    figlet linux
    fortune
    显示数据库中提取的一句诗句
    sl
    sl火车开过
    其他的一些命令hack pacman4console  snake celestia

screenfetch cmatrix asciiquarium toilet espeak oneka basket 
快速安装 yes | 安装命令
20.ansi escape code & bash命令行提示符
（1）元字符概述 shell对许多字符的处理不按照字面意思进行处理，这样的特殊字符时元字符（meta character）
；顺序执行
& 异步执行
`ls` --执行相关命令生成字符串，  等价于$(ls)
‘’—不做解释
“”--解释完成输出
​
添加图片注释，不超过 140 字（可选）
（2）bash命令行提示符
提示符的颜色通过ansi转义序列表示，所有的颜色序列用\[\033[和m\[括起来
ANSI转义序列是一种带内信号的转义序列标准，用于控制视频文本终端上的光标位置、颜色和其他选项。在文本中嵌入确定的字节序列，大部分以ESC转义字符和"["字符开始，终端会把这些字节序列解释为相应的指令，而不是普通的字符编码。
发送的都是ascii字符，只是在接受端的解释会不一样
----terminfo
terminfo取代庞大的 /etc/termcap 文件来定制终端的外观和交互行为。 编译好的数据库文件在 /usr/share/terminfo 下，用 infocmp 命令来反编译输出各种终端类型的特性描述文件。如 infocmp vt100。 用 tic -c terminfo格式源文件  来校验，然后  tic -s terminfo格式源文件 来修改数据库。然后打开一个新终端，用 stty -a 来检查当前终端的性能参数。
----termcap
不同字符序列作为控制段的开头，进行不同的解释。检测不同用户使用的终端，进统一检测—termcap
包含自己的数据库，屏蔽终端区别，提供统一开放的api，支持跨平台文本模式应用开发。数据库存放信息，使用berkeley db数据库。
系统中的环境变量 TERM存放终端名称
echo $TERM –显示终端颜色和终端类型
termcap存放termcap数据库的位置termpath存储termcap文件的搜索路径
不同终端经过termcap和terminfo后汇聚到curse文本形式的图形界面编成
----ansi escape code支持情况
unix 支持
dos/windows dos系统不支持
windows console 不支持
windows power5.1 默认支持
----escape sequence
序列没有固定的长度   
在linux console显示各种颜色的信息可以使用特殊的符号串：escape sequence code,使得在linux终端以高亮，粗体，闪烁、多种颜色等方式展示消息
1.读到\033，说明后面的字符是ANSI escape sequence，会特殊处理
2.使用[34m 来设定终端的前景色为蓝色
3.打印 Hello Colorful World\! ，颜色为蓝色
\033[ 实际上在输入的文本信息中作为一个特殊标识，终端读到 \033 字符的时候，识别出这是一个escape character；将切换到escape模式。然后读取“[” 字符移入到CSI模式（Command Sequence Introduction (CSI) mode），在CSI模式下，终端读取这些ASCII码用分号“；”隔开，直到读入一个完整的动作指令（开头+参数字节+间格字节+终止字节 没有参数默认使用0填充）。
\033[1;31mhello world\033[0m   0可以删除，不受任何影响
不同颜色在不同系统中的编码不一样3/4 bit 30-37前景色 40-47背景色
24-bit真彩色 3个字节，rgb各是一个字节，前景背景
举例：

    echo -e ”\e[0;31mhello\e[0m” 其中\e中的e就是033代表esc
    tput命令所设置任何颜色—系统

安装以下常用目录：
git
vim
pandoc—文档格式的瑞士军刀
textlive-latex-base latex进行排版的工具
pkg-config c语言变成需要使用
3.termcap terminfo绪
/etc/terminfo/README
This directory is for system-local terminfo descriptions. By default,
ncurses will search ${HOME}/.terminfo first, then /etc/terminfo (this
directory), then /lib/terminfo, and last not least /usr/share/terminfo.
Tic:terminfo编译器
infocmp:terminfo信息显示及比较器
captoinfo:从termcap描述到terminfo描述的转换器
tput:可以由shell脚本访问的使用terminfo能力的应用
4.ncurses—提供了一套底层终端代码之上的封装，向用户提供了灵活高校的api，包括移动光标，建立窗口，产生颜色，处理鼠标操作等等
ncurses(new curses)是一套编程库，它提供了一系列的函数以便使用者调用它们去生成基于文本的用户界面。 
ncurses名字中的n意味着“new”，因为它是curses的自由软件版本。由于AT&T“臭名昭著”的版权政策，人们不得不在后来用ncurses去代替它。 
为了能够使用ncurses库,您必须在您的源程序中将curses.h包括(include)进来,而且在编译的需要与它连接起来. 在gcc中您可以使用参数-lcurses进行编译.
在使用ncurses的时候,您有必要了解它的基础数据结构.它有一个WINDOW结构,从名字就很容易知道,它是用来描述 您创建的窗体的,所有ncurse库中的函数都带有一个WINDOW指针参数.
在ncurses中使用最多的组件是窗体.即使您没有创建自己的窗体,当前屏幕会认为是您自己的窗体. 如同标准输入输出系统提供给屏幕的文件描述符stdout一样(假设没有管道转向),ncurses提供一个 WINDOW指针stdscr做相同工作.除了stdscr外,ncurses还定义了一个WINDOW指针curscr. 和stdscr描述当前屏幕一样,curscr描述当前在库中定义的屏幕

ncurses是GNU计划的一部分，但它却是少数几个不使用GNU GPL或LGPL授权的GNU软件之一。
相关库 menu panel form等库
apt-cache serach ncurses | grep dev 
dpkg -L XX 查看安装文件的具体内容
a静态链接库 so动态链接库
5.screen tmux
（1）screen
执行screen命令后，screen就运行在后台了
tracer@tracerX:/etc/terminfo$ ps ax | grep screen
   1977 ?        Ssl    0:00 /usr/libexec/gsd-screensaver-proxy
   9453 pts/0    S+     0:00 screen
   9463 pts/1    S+     0:00 grep --color=auto screen
通过ctrl ac创建新的窗口 ctrl an用于切换创建的窗口 
恢复当初screen所作的工作screen attach
退出时ctrl ad
（2）tmux使用更加频繁
6. 命令行参数 $ps1—命令行提示信息
$(data)显示当前的信息
命令可以修改命令行的颜色
\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$
7.mc、ranger
文本窗口的资源管理器
8.ponysay命令
ponysay “hello”
 for i in $(ponysay –all);do ponysay -f $i”hello”;done
ponysay.ponythink “hello”
9. 命令行操作
（1）历史命令记录的操作
~/.bash_history文件中存储相关的命令，显示记录的条数有HISTSIZE环境变量来决定
存储由HISTFILESIZE来决定
HISTCMD显示当前的行号
echo $HISTCMD
$HISTCMD       $HISTCONTROL   $HISTFILE（存储的文件）      $HISTFILESIZE  $HISTSIZE
（2）！的使用
！n运行第n条命令
！-n执行倒数第n个历史记录
！#目前已经键入的整个命令行的内容
！sudo最近执行sudo的命令
!!执行上一个命令
^a^c重复上一个历史命令，将其中的a还为c
！！：o上一个历史记录的命令名 1-第一个参数 2-第2个参数
！$上一个命令的最后一个参数
命令行中ctrl s暂停，输入内容不再显示  ctrl q可以恢复具体的命令
ctrl r 在历史记录中向前搜索
（3）ctrl meta（alt）使用
c a-行首
c e 行尾部
c b左移一个字符
c f右移一个字符
m b左移一个单词
mf右移一个单词
c h删除光标左边的字符
cd删除光标所在位置的字符
c _ 撤销编辑操作
cy粘贴
m d剪切到单词尾
ck剪切到行尾部
cu剪切到行首
mt交换当前光标及其左边的两个单词
m u将当前单词大写
m l将当前单词小写
m * 列出可以输入的命令
（4）命令行自动补全
m / 补全文件名
m ～补全用户名
m @补全主机名
m$补全变量名
m！补全命令名
m^补全历史记录
(5)不显示命令到history--输入命令前面加入空格
-----------------------------------chacpter3：linux磁盘与文件管理系统------------------------------------
1.设备文件
unix-like中一切都是文件，普通文件、目录、磁盘、套接字也是文件
mknod创建设备文件—繁琐
----（1）一些设备文件说明
fd：软盘
hd：经典硬盘（ATA接口）
sd：scsi驱动硬盘，其他设备也用
mount命令查看所设设备的挂在情况
/挂载在/dev/sda1 ext4==表示文件分区类型relatime表示仅仅更改access time
ip：line printer
pt伪终端
tty终端
----（2）一些伪设备
/dev/null相当于文件黑洞，输入进去之后不现实任何内容
任何应用启动时会打开三个文件 0 stdin--标准输入1 –标准输出2--错误输出
/dev/zero会产生连续的0字符-伪字符
cat -A /dev/zero -A参数代表现实所有字符
/dev/full永远被填满的设备—磁盘满的设备进行模拟--应用程序会怎么样
/dev/loop循环接口，使得文件可以如同块设备一样访问。iso文件本身有目录结构，首先创建iso文件 genisoimage—相同命令：：：mkisofs--mkisofs -o my.iso 2020 取出2020目录的文件，写成my.iso文件，losetup将iso文件和当前设备中的loop相关联，losetup /dev/loop18 my.iso把当前设备挂载到当前系统中去，同时把关联的设备 /dev/loop18 映射到当前系统中，如/mnt目录，sudo mkdir  /mnt/iso;接下来使用mount命令，mount /dev/loop18  /mnt/iso。iso文件一般写保护。
另一种方式直接挂载
mount ： sudo mount -o loop my.iso /mnt/iso 按循环设备的方式把文件映射到目录中
sudo umount /mnt/iso:取消挂载操作
/dev/random 阻塞 产生任意长度的随机序列—随机性高；但是会依据系统进行判断。
cat /dev/random | od -x 以十进制数显示出来
cat /dev/random | od -x | tr -d ‘’  去除空格进行显示
cat /dev/random | od -x | tr -d ‘’  | head -n 1只显示1行
/dev/urandon非阻塞  产生任意长度的随机序列
----（3）补充内容
在类Unix操作系统中，设备文件或特殊文件是设备驱动程序的接口，出现在文件系统中就好像它是普通文件一样。在MS-DOS，OS / 2和Microsoft Windows中也有特殊文件。 这些特殊文件允许应用程序通过标准输入/输出系统调用使用其设备驱动程序与设备进行交互。使用标准系统调用简化了许多编程任务，并且无论设备的特性和功能如何，都可以实现一致的用户空间I / O机制。
设备文件通常提供与标准设备（如打印机和串行端口）的简单接口，但也可用于访问这些设备（如磁盘分区）上的特定独特资源。此外，设备文件对于访问与任何实际设备（如数据接收器和随机数生成器）无关的系统资源非常有用。
2. 硬盘相关知识； inode概述； 硬盘分区、格式化、挂载 ；文件系统相关命令（df/du等）
sda分区、格式化等操作
（1）硬盘相关知识
分为普通硬盘3.5存—电机旋转、固态硬盘；
电脑硬盘是计算机最主要的存储设备。硬盘（港台称之为硬碟，英文名：Hard Disk Drive， 简称HDD 全名温彻斯特式硬盘）由一个或者多个铝制或者玻璃制的碟片组成。这些碟片外覆盖有铁磁性材料。
绝大多数硬盘都是固定硬盘，被永久性地密封固定在硬盘驱动器中。早期的硬盘存储媒介是可替换的，不过今日典型的硬盘是固定的存储媒介，被封在硬盘里 （除了一个过滤孔，用来平衡空气压力）。随着发展，可移动硬盘也出现了，而且越来越普及，种类也越来越多.大多数微机上安装的硬盘，由于都采用温切斯特（winchester)技术而被称之为“温切斯特硬盘”，或简称“温盘”。
（2）外部
盘体—密封的腔体，其内部结构就是通常提及的硬盘内部结构
控制电路板—硬盘bios、硬盘缓存，主控芯片
接口部件--电源插座、数据接口、跳线。
（3）内部
盘体、磁头--读写头、数据组织（磁道、扇区、柱面、扇区--交叉因子适配速度差、簇）
固态硬盘使用芯片进行存储，不是使用磁介质进行存储的。
3.磁盘数据读写的过程
磁盘上数据必须用一个三维地址唯一标示：柱面号、盘面号、扇区号(磁道上的盘块)。
读过程：
当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。
为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点：
1）首先必须找到柱面，即磁头需要移动对准相应磁道，这个过程叫做寻道或定位；
2） 盘面确定以后，盘片开始旋转，将目标扇区旋转到磁头下。
即一次访盘请求（读/写）完成过程由三个动作组成：
1）寻道（时间）：磁头移动定位到指定磁道，这部分时间代价最高，最大可达到0.1s左右；
2）旋转延迟（时间）：等待指定扇区旋转至磁头下。与硬盘自身性能有关，xxxx转/分；
3）数据传输（时间）：数据通过系统总线从磁盘传送到内存的时间，一般传输一个字节大概0.02us。
写过程：
文件的记录在同一盘组上存放时，应先集中放在一个柱面上，然后再顺序存放在相邻的柱面上，对应同一柱面，则应该按盘面的次序顺序存放。
4.与boot相关的概念
硬盘分区表 MBR GPT
主板类型 BIOS（主版输入输出系统，仅仅支持MBR）、UEFI（仅仅支持GPT）
MBR—硬盘0柱面0磁头1扇区 512字节，包含主引导程序、磁盘分区表dpt；16个字节对应一个分区
gpt—mbr改进技术，一种更先进的组织方式，支持2T以上的磁盘分区，使用uefi启动
5.MBR 硬盘描述
硬盘是现在计算机上最常用的存储器之一。我们都知道，计算机之所以神奇，是因为它具有高速分析处理数据的能力。而这些数据都以文件的形式存储在硬盘里。不过，计算机可不像人那么聪明。在读取相应的文件时，你必须要给出相应的规则。这就是分区概念。 
    分区从实质上说就是对硬盘的一种格式化。当我们创建分区时，就已经设置好了硬盘的各项物理参数，指定了硬盘主引导记录（即Master Boot Record，一般简称为MBR）和引导记录备份的存放位置。而对于文件系统以及其他操作系统管理硬盘所需要的信息则是通过以后的高级格式化，即 Format命令来实现。面、磁道和扇区硬盘分区后，将会被划分为面（Side）、磁道（Track）和扇区（Sector）。需要注意的是，这些只是个 虚拟的概念，并不是真正在硬盘上划轨道。
    先从面说起，硬盘一般是由一片或几片圆形薄膜叠加而成。我们所说，每个圆形薄膜都有两个“面”，这两个面都是用来存储数据的。按照面的多少，依次称为0 面、1面、2面……由于每个面都专有一个读写磁头，也常用0头(head)、1头……称之。按照硬盘容量和规格的不同，硬盘面数(或头数)也不一定相同， 少的只有2面，多的可达数十面。各面上磁道号相同的磁道合起来，称为一个柱面(Cylinder)。
    上面我们提到了磁道的概念。那么究竟何为磁道呢？由于磁盘是旋转的，则连续写入的数据是排列在一个圆周上的。我们称这样的圆周为一个磁道。如果读写磁头沿 着圆形薄膜的半径方向移动一段距离，以后写入的数据又排列在另外一个磁道上。根据硬盘规格的不同，磁道数可以从几百到数千不等；一个磁道上可以容纳数KB 的数据，而主机读写时往往并不需要一次读写那么多，于是，磁道又被划分成若干段，每段称为一个扇区。一个扇区一般存放512字节的数据。扇区也需要编号， 同一磁道中的扇区，分别称为1扇区，2扇区……
    计算机对硬盘的读写，处于效率的考虑，是以扇区为基本单位的。即使计算机只需要硬盘上存储的某个字节，也必须一次把这个字节所在的扇区中的512字节全部 读入内存，再使用所需的那个字节。不过，在上文中我们也提到，硬盘上面、磁道、扇区的划分表面上是看不到任何痕迹的，虽然磁头可以根据某个磁道的应有半径 来对准这个磁道，但怎样才能在首尾相连的一圈扇区中找出所需要的某一扇区呢？原来，每个扇区并不仅仅由512个字节组成的，在这些由计算机存取的数据的 前、后两端，都另有一些特定的数据，这些数据构成了扇区的界限标志，标志中含有扇区的编号和其他信息。计算机就凭借着这些标志来识别扇区。硬盘的数据结构 在上文中，我们谈了数据在硬盘中的存储的一般原理。为了能更深入地了解硬盘，我们还必须对硬盘的数据结构有个简单的了解。硬盘上的数据按照其不同的特点和 作用大致可分为5部分：MBR区、DBR区、FAT区、DIR区和DATA区。
1、MBR区
      MBR（Main Boot Record 主引导记录区）位于整个硬盘的0磁道0柱面1扇区。不过，在总共512字节的主引导扇区中，MBR只占用了其中的446个字节，另外的64个字节交给了 DPT（Disk Partition Table硬盘分区表），最后两个字节“55，AA”是分区的结束标志。这个整体构成了硬盘的主引导扇区。
    主引导记录中包含了硬盘的一系列参数和一段引导程序。其中的硬盘引导程序的主要作用是检查分区表是否正确并且在系统硬件完成自检以后引导具有激活标志的分 区上的操作系统，并将控制权交给启动程序。MBR是由分区程序（如Fdisk．exe）所产生的，它不依赖任何操作系统，而且硬盘引导程序也是可以改变 的，从而实现多系统共存。
    下面，我们以一个实例让大家更直观地来了解主引导记录：
    例：80 01 01 00 0B FE BF FC 3F 00 00 00 7E 86 BB 00 在这里我们可以看到，最前面的“80”是一个分区的激活标志，表示系统可引导；“01 01 00”表示分区开始的磁头号为01，开始的扇区号为01，开始的柱面号为00；“0B”表示分区的系统类型是FAT32，其他比较常用的有 04（FAT16）、07（NTFS）；“FE BF FC”表示分区结束的磁头号为254，分区结束的扇区号为63、分区结束的柱面号为764；“3F 00 00 00”表示首扇区的相对扇区号为63；“7E 86 BB 00”表示总扇区数为12289622。
2、DBR区
    DBR（Dos Boot Record）是操作系统引导记录区的意思。它通常位于硬盘的0磁道1柱面1扇区，是操作系统可以直接访问的第一个扇区，它包括一个引导程序和一个被称为 BPB（Bios Parameter Block）的本分区参数记录表。引导程序的主要任务是当MBR将系统控制权交给它时，判断本分区跟目录前两个文件是不是操作系统的引导文件（以DOS为 例，即是Io．sys和Msdos．sys）。如果确定存在，就把它读入内存，并把控制权 交给该文件。BPB参数块记录着本分区的起始扇区、结束扇区、文件存储格式、硬盘介质描述符、根目录大小、FAT个数，分配单元的大小等重要参数。DBR 是由高级格式化程序（即Format．com等程序）所产生的。
3、FAT区
    在DBR之后的是我们比较熟悉的FAT（File Allocation Table文件分配表）区。在解释文件分配表的概念之前，我们先来谈谈簇（Cluster）的概念。文件占用磁盘空间时，基本单位不是字节而是簇。一般情 况下，软盘每簇是1个扇区，硬盘每簇的扇区数与硬盘的总容量大小有关，可能是4、8、16、32、64…… 同一个文件的数据并不一定完整地存放在磁盘的一个连续的区域内，而往往会分成若干段，像一条链子一样存放。这种存储方式称为文件的链式存储。由于硬盘上保 存着段与段之间的连接信息（即FAT），操作系统在读取文件时，总是能够准确地找到各段的位置并正确读出。 为了实现文件的链式存储，硬盘上必须准确地记录哪些簇已经被文件占用，还必须为每个已经占用的簇指明存储后继内容的下一个簇的簇号。对一个文件的最后一 簇，则要指明本簇无后继簇。这些都是由FAT表来保存的，表中有很多表项，每项记录一个簇的信息。由于FAT对于文件管理的重要性，所以FAT有一个备 份，即在原FAT的后面再建一个同样的FAT。初形成的FAT中所有项都标明为“未占用”，但如果磁盘有局部损坏，那么格式化程序会检测出损坏的簇，在相 应的项中标为“坏簇”，以后存文件时就不会再使用这个簇了。FAT的项数与硬盘上的总簇数相当，每一项占用的字节数也要与总簇数相适应，因为其中需要存放 簇号。FAT的格式有多种，最为常见的是FAT16和FAT32。
4、DIR区
DIR（Directory）是根目录区，紧接着第二FAT表（即备份的FAT表）之后，记录着根目录下每个文件(目录)的起始单元，文件的属性等。定位文件位置时，操作系统根据DIR中的起始单元，结合FAT表就可以知道文件在硬盘中的具体位置和大小了。
5、数据(DATA)区
    数据区是真正意义上的数据存储的地方，位于DIR区之后，占据硬盘上的大部分数据空间。
6.inode
/dev/sda5 on / type ext4 (rw,relatime,errors=remount-ro)
模拟配置一块硬盘，接到磁盘中的操作
模拟操作如下
（1.查看机器中的硬盘--自己分区的硬盘
sudo fdisk -l /dev/sda 
m for help
（2.根据help进行操作
硬盘分区有三种，主磁盘分区、扩展磁盘分区、逻辑分区。
一个硬盘可以有一个主分区，一个扩展分区，也可以只有一个主分区没有扩展分区。逻辑分区可以若干。
主分区是硬盘的启动分区，他是独立的，也是硬盘的第一个分区，正常分的话就是C驱。
分出主分区后，其余的部分可以分成扩展分区，一般是剩下的部分全部分成扩展分区，也可以不全分，那剩的部分就浪费了。
但扩展分区是不能直接用的，他是以逻辑分区的方式来使用的，所以说扩展分区可分成若干逻辑分区。他们的关系是包含的关系，所有的逻辑分区都是扩展分区的一部分
硬盘的容量＝主分区的容量＋扩展分区的容量
扩展分区的容量＝各个逻辑分区的容量之和
主分区也可成为“引导分区”，会被操作系统和主板认定为这个硬盘的第一个分区。所以C盘永远都是排在所有磁盘分区的第一的位置上。
除去主分区所占用的容量以外，剩下的容量被认定为扩展分区。通俗的讲就是主分区是硬盘的主人，而扩展分区是这个硬盘上的仆人，主分区和扩展分区为主从关系。
扩展分区如果不再进行分区了，那么扩展分区就是逻辑分区了。如果还需要进行分区操作的话，则所谓的逻辑分区只能从扩展分区上操作。就相当于在仆人中（扩展分区上）进行细分类，分成接电话的（D盘）、扫地的（E盘）、做饭的（F盘）等等。
所以扩展分区和逻辑分区的关系相当于再分类关系。
（3.划分分区之后进行格式化
sudo mkfs.ext4 /dev/sdb1
sudo mkfs.ext4 /dev/sdb3
sudo mkfs.ext4 /dev/sdb5等等操作
（4.创建分区之后需要挂载到系统中，在系统中/mnt目录下创建目录提供挂载点
sudo mkdir disk{1,3,5,6}
（5.把创建的分区挂载到目录中
sudo mount /dev/sdb1 disk1
sudo mount /dev/sdb3 disk3
sudo mount /dev/sdb5 disk5
（6.使用mount命令查看当前的挂载情况
mount挂载之后就可以对目录进行读写，cd disk1 → touch test 读写文件(需要查看权限)
（7.更改权限
sudo chown tracer:tracer disk* 由此可以由本级用户对磁盘进行操作
（8.unmount硬盘
需要把硬盘从系统目录中卸载可以使用
sudo umount /dev/sdb1
或者
sudo umount /mnt/disk3
或者
sudo umount -a
（9.读扇区的内容：
sudo dd if=/dev/sda ibs=512 count=1 >sda512 把读取的内容定向到sda512
使用hexedit进行查看
----补充讲解inode

    inde是linux文件系统的数据结构，用于描述文件系统对象（文件、目录、设备文件、socket、管道等）
    每一个文件与一个inode相关联
    每一个文件与一个inode相关联，inode保存文件的元信息，相关信息可以用stat查看
    ls -i 文件 会列出文件的inode信息
    blocks—块的意思，扇区的意思 ，512个字节一个扇区，真正读写一次读取8个扇区-4K
    clac进行命令的计算 clac 365*542
    硬链接使得文件的inode一样。
    硬盘格式化时，操作系统会将其分为两个区域

存储inode（每个inode占用128字节，一般每1KB或者2KB就设置一个inode）和存储实际数据的区域（常见为512字节的扇区，每8扇区组成的4K数据块，块是数据读写的单位）
bootblock--启动块（MBR） blockgroup0 blockgroup1 … blockgroupN
每个组包含若干个inode及其指示、数据块及其指示等内容
inode总数一般是固定的，文件夹时inode的名字，包含自身节点、父亲节点、每个子结点。
Df -i命令可以查看磁盘存放的inode节点数目。
sudo mkfs.ext4 文件  --是否格式化 回车之前需要谨慎
查看整个磁盘的bg个数：512个group 32768个block 4K*8对应inode
(1 sudo debugfs /dev/sda1 敲击help查看帮助
(2 输入stats当前磁盘的概述信息
新窗口输入df -h查看磁盘的信息
(3 dump <3833858> mypasswd取出节点的数据块信息，存储到mypasswd文件中
(4 extents取代一级指针 stat查看文件的信息
(5 icheck 4236248得到inode
磁盘操作时inode具体工作
文件的inode存储内容的位置
目录的inode存储文件的信息
（1）理解inode：理解inode，要从文件储存说起。
文件储存在硬盘上，硬盘的最小存储单位叫做"扇区"（Sector）。每个扇区储存512字节（相当于0.5KB）。
操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个"块"（block）。这种由多个扇区组成的"块"，是文件存取的最小单位。"块"的大小，最常见的是4KB，即连续八个 sector组成一个 block。
文件数据都储存在"块"中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为"索引节点"。
每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。
（2）inode包含的元信息
inode包含文件的元信息，具体来说有以下内容：
　　* 文件的字节数
* 文件拥有者的User ID
　　* 文件的Group ID
　　* 文件的读、写、执行权限
　　* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。
　　* 链接数，即有多少文件名指向这个inode
　　* 文件数据block的位置
（3）inode的大小
inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令。
（4）inode号码
每个inode都有一个号码，操作系统用inode号码来识别不同的文件。
这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。
表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。
使用ls -i命令，可以看到文件名对应的inode号码
（5）硬链接 （ln 源文件 目标文件）
一般情况下，文件名和inode号码是"一一对应"关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。
这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为"硬链接"（hard link）。
运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做"链接数"，记录指向该inode的文件名总数，这时就会增加1。
反过来，删除一个文件名，就会使得inode节点中的"链接数"减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。
这里顺便说一下目录文件的"链接数"。创建目录时，默认会生成两个目录项："."和".."。前者的inode号码就是当前目录的inode号码，等同于当前目录的"硬链接"；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的"硬链接"。所以，任何一个目录的"硬链接"总数，总是等于2加上它的子目录总数（含隐藏目录）。
（6）软链接
除了硬链接以外，还有一种特殊情况。
文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的"软链接"（soft link）或者"符号链接（symbolic link）。
这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错："No such file or directory"。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode"链接数"不会因此发生变化。
ln -s命令可以创建软链接。
ln -s 源文文件或目录 目标文件或目录
（7）inode特殊作用
由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象。
　　1. 有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。
　　2. 移动文件或重命名文件，只是改变文件名，不影响inode号码。
　　3. 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。
第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。
（8）inode中的指针--通过读节点的内容，得知数据存储的位置，由此读取文件的全部内容。
​
添加图片注释，不超过 140 字（可选）
磁盘碎片整理--以前整理磁盘方便快速读取--以前的读取方式，现在以块的形式进行。
（9）stat <inode> 查看节点信息
dump命令存储节点的信息到一个文件：dump <inodenumber> 文件
tracer@tracerX:~$ stat /
  文件：/
  大小：4096      块：8          IO 块：4096   目录
设备：805h/2053dInode：2           硬链接：20(相当于子目录的数量)
权限：(0755/drwxr-xr-x)  Uid：(    0/    root)   Gid：(    0/    root)
最近访问：2022-02-24 15:21:33.468000170 +0800
最近更改：2022-02-19 20:51:37.197691719 +0800
最近改动：2022-02-19 20:51:37.197691719 +0800
创建时间：-
(10)
echo “obase=16;10024”|bc  计算十六进制的数据
Dumpe2fs 查看ext2/3/4系列文件系统的相关信息
blkid：查看系统被格式化的装置的id
7.文件的存取与日志式文件系统的功能--写数据时先写进缓存在写入硬盘--导致数据不一致问题，缓存没有写入磁盘，可能会导致数据的丢失
数据不一致性问题，相关命令：sync、fsck（man命令查看使用手册）windows-chkdsk
日志式文件系统：存储文件的操作记录，出现不一致问题，只需要对相关文件做恢复操作，避免对整个文件系统进行检查，提升效率
8.linux支持的文件系统—传统、日志式、网络文件系统
uanme-a 查看当前使用的内核
/lib/modules/$(uname -r)/kernal/fs支持的文件系统
cat /proc/filesystem查看支持的文件系统
Linux操作系统使用虚拟文件系统（VFS）向上和用户进程文件访问系统调用接口，向下和具体不同文件系统的实现接口。VFS屏蔽了具体文件的实现细节，向上提供统一的操作接口。
通过VFS可以实现任意的文件系统，这些文件系统通过文件访问系统调用都可以访问。所以Linux系统核心可以支持十多种文件系统类型，比如Btrfs、JFS、 ReiserFS、ext、ext2、ext3、ext4、ISO9660、XFS、Minx、MSDOS、UMSDOS、VFAT、NTFS、HPFS、NFS、SMB、SysV、PROC等。
下面说明其支持的几个重要的文件系统
ext专门为Linux设计的，为linux核心所做的第一个文件系统。单个文件最大限制：未知；该文件系统最大支持2GB的容量。
ext2由Rémy Card设计，用以代替ext，是LINUX内核所用的文件系统。单个文件最大限制2TB；该文件系统最大支持32TB的容量。
ext3一个日志文件系统。单个文件最大限制16TB，该文件系统最大支持32TB的容量。
ext4Theodore Tso领导的开发团队实现,Linux系统下的日志文件系统。单个文件最大限制16TB，该文件系统最大支持1EB的容量。
JFS2一种字节级日志文件系统,该文件系统主要是为满足服务器的高吞吐量和可靠性需求而设计、开发的。单个文件最大限制16TB，该文件系统最大支持1PB的容量。
9.文件系统的相关操作
（1）df命令  列出文件系统的整体磁盘使用量
-h humanreadable 人读出来比较舒服的形式
-i inode方式显示
du -sh. 评估文件系统的磁盘使用量 s-summary 全部的
du -d 1 /home 看一级目录使用的情况
（2）sudo vi /etc/fstab关于filesystem的配置文件
（3）iso文件挂载使用loop  制作iso文件 --dd命令  if=  of=
（4）swap分区内存的延伸==磁盘延伸内存
----------------------------------chacpter4：文件的压缩打包以及备份------------------------------------
1.压缩文件类型
GZIP file format specification version 4.3---自己编写压缩程序
linux常见的压缩类型 .z .zip .gz .bz2 (tar程序打包).tar .tar.gz .tar.bz2 .tar.xz .xz
2.常见的压缩命令
gzip zcat zmore zless zgrep

    gzip为了取代compress而出现
    gzip [-CDTV#] 文件名  #表示压缩数字
    c输出压缩数据 d解压缩 t检验压缩文件的一致性 v显示出压缩文件压缩比等信息 #1最快压缩比最差
    gzip -9 -c server >server.gz
    zcat server.gz纯文本文件压缩，zcat可以直接查看文件 zmore zless是类似的命令
    zgrep “width” ls.1.gz 查看压缩文件中包含width关键词的内容
    bzip2取代gzip开发 压缩时间🦸慢，压缩比率高

bzip2 [-CDKTV#] 文件名 K-保留原文件  v-显示压缩比特信息
（3）xz
参数-t测试压缩文件的完整性
xzcat xzmore xzless进行文件的查看
（4）打包指令tar命令  t-tap磁带 ar-artap归档
tar [-z|-j|-J] [cv] [-f 想要创建的文件名]  filename 压缩
-c 建立打包文件  -t查看打包文件的内容
-x解压缩
cvf   v-visible显示操作过程 f-针对文件的操作 c-create创建
tvf t-test测试
xvf  x-解压
tar cvf mytar 1把1打包到mytar  不加-xvf的命令 tar命令出现时间早，可以不加
创建tar文件并进行压缩—gzip xz的步骤
1）tar cvf my.tar 1
2）gzip my.tar  生成tar.gz文件
3）解压所gzip -d my.tar.gz
一步骤完成工作
tar cvfz/j/J data.tar.gz 1   z-gzip压缩   j-bz2进行压缩  J-xz进行压缩
可以使用file命令查看文件类型
xvfz/j/J 进行解压
其他会用的参数：：：：-p 保持备份数据的原来权限与属性
   --exclude==FILE 压缩过程中，不将file打包
2.使用管道示例
tar -cvf - /etc | tar -xvf – 将/etc文件拷贝到当前目录
第一个-：表示标准输出 第二个-：表示标准输入
3.xfs文件系统备份 省略
4.光盘相关
（1）创建iso文件
mkisofs命令  -o制定输出文件 -r 光盘文件系统标准 -v显示创建iso文件的详细过程
mount -o loop /dev/ss.img /dev
（2）dd if=  of= bs= count= 备份文件、从磁带制作映像
cpio命令 主要目的是数据的备份 copy file to and from  archives
----------------------------------chacpter5：vim编辑器的使用------------------------------
1.etc文件中的文件配置，log查看日志文件—对文本文件处理，提高工作速率，编辑其可以通过编程来扩展
2.ed—最古老的编辑器  emacs—20M  vim—10M
ed受qed编辑器的影响，使用了正则表达式，是一种行编辑器
ed greeting 
输入的任何内容都是命令—不知道报？ a—切换到编辑模式  . --切换到命令模式
1p(1,$p)打印第一行 1c修改第一行—进入编辑模式 q代表退出 w代表退出
3.ex ed的扩展 网速变快
vi—bill joy(sun公司的创始人)
4.vim编辑器的基本功能 vi的改进版本—vim
vim不断发展，8.2版本 功能逐渐齐全
www.vim.org—vim所需要的插件
三种模式—
命令模式—移动光标，不会回显，马上执行
编辑模式 I i o O a A r R i-进入插入模式 open replace append，使用esc回到命令模式
命令行模式 command line 最后行模式，命令模式下输入 ： / ？光标会移动到最后一行，可供命令输入（搜索、存储、替换字符、退出vi等设置）esc回到命令模式
refernce card—一些常见的功能列表总结，使用热键完成功能
vi就是vim的符号链接，执行内容都一样
：write存盘 
： f test编辑文件名
：q退出
------vi编辑器能做的功能
命令模式下：
光标移动 hjkl h-左 l-右 j下k上  30j直接移动30个字符
ctrl f—向下移动一页 ctrl b上移动一页 ctrl d向下移动半页 ctrl u向上移动半页面
+移动到非空格符号的下列  -移动到上一行
u undo 取消操作
:1,$s/,//g   1第一行 $最后一行 s/查找 ，/空格 g全部执行
gg回到第一行 G回到最后一行
:x 存盘退出
: w first.txt存盘成其他文件
set number显示行数
第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等 
移动光标的方法
h 或 向左箭头键(←)
	
光标向左移动一个字符
j 或 向下箭头键(↓)
	
光标向下移动一个字符
k 或 向上箭头键(↑)
	
光标向上移动一个字符
l 或 向右箭头键(→)
	
光标向右移动一个字符
如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 "30j" 或 "30↓" 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！
[Ctrl] + [f]
	
屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)
[Ctrl] + [b]
	
屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)
[Ctrl] + [d]
	
屏幕『向下』移动半页
[Ctrl] + [u]
	
屏幕『向上』移动半页
+
	
光标移动到非空格符的下一行
-
	
光标移动到非空格符的上一行
n<space>
	
那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。
0 或功能键[Home]
	
这是数字『 0 』：移动到这一行的最前面字符处 (常用)
$ 或功能键[End]
	
移动到这一行的最后面字符处(常用)
H
	
光标移动到这个屏幕的最上方那一行的第一个字符
M
	
光标移动到这个屏幕的中央那一行的第一个字符
L
	
光标移动到这个屏幕的最下方那一行的第一个字符
G
	
移动到这个档案的最后一行(常用)
nG
	
n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)
gg=G
	
对当前文档进行格式化 对齐文本等操作
gg
	
移动到这个档案的第一行，相当于 1G 啊！ (常用)
n<Enter>
	
n 为数字。光标向下移动 n 行(常用)
查找与替换
	
/word
	
向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)
?word
	
向光标之上寻找一个字符串名称为 word 的字符串。
n
	
这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！
N
	
这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。
使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！
:n1,n2s/word1/word2/g
	
n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：『:100,200s/vbird/VBIRD/g』。(常用)
:1,$s/word1/word2/g 或 :%s/word1/word2/g
	
从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)
:1,$s/word1/word2/gc 或 :%s/word1/word2/gc
	
从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)
复制粘贴命令
	
x, X
	
在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)
nx
	
n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。
dd
	
剪切游标所在的那一整行(常用)，用 p/P 可以粘贴。
ndd
	
n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p/P 可以粘贴。
d1G
	
删除光标所在到第一行的所有数据
dG
	
删除光标所在到最后一行的所有数据
d$
	
删除游标所在处，到该行的最后一个字符
d0
	
那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符
yy
	
复制游标所在的那一行(常用)
nyy
	
n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)
y1G
	
复制游标所在行到第一行的所有数据
yG
	
复制游标所在行到最后一行的所有数据
y0
	
复制光标所在的那个字符到该行行首的所有数据
y$
	
复制光标所在的那个字符到该行行尾的所有数据
p, P
	
p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)
J
	
将光标所在行与下一行的数据结合成同一行
c
	
重复删除多个数据，例如向下删除 10 行，[ 10cj ]
cc
	
替换整行
cw
	
替换一个单词
u
	
复原前一个动作。(常用)
[Ctrl]+r
	
重做上一个动作。(常用)
Ctrl l
	
重画屏幕，刷新屏幕
这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！
.
	
不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)
字的概念 ：广义（空格之间）、狭义（特殊标点和字符均被当作一个字）
拷贝到寄存器”a yy 拷贝内容到a寄存器  拷贝10行到a寄存器
：reg查看寄存器的内容
：help registers查看相关的帮助文档
第二部分：一般模式切换到编辑模式的可用的按钮说明
进入输入或取代的编辑模式
i, I
	
进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)
a, A
	
进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)
o, O
	
进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用)
r, R
	
进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)
上面这些按键中，在 vi 画面的左下角处会出现『--INSERT--』或『--REPLACE--』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！
[Esc]
	
退出编辑模式，回到一般模式中(常用)
第三部分：一般模式切换到指令行模式的可用的按钮说明
指令行的储存、离开等指令
:w
	
将编辑的数据写入硬盘档案中(常用)
:w!
	
若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！
:q
	
离开 vi (常用)
:q!
	
若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。
注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～
:wq
	
储存后离开，若为 :wq! 则为强制储存后离开 (常用)
ZZ
	
这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)
ZQ
	
不保存，强制退出。效果等同于 :q!。
:w [filename]
	
将编辑的数据储存成另一个档案（类似另存新档）
:r [filename]
	
在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面
:n1,n2 w [filename]
	
将 n1 到 n2 的内容储存成 filename 这个档案。
:! command
	
暂时离开 vi 到指令行模式下执行 command 的显示结果！例如『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！
vim 环境的变更
:set nu
	
显示行号，设定之后，会在每一行的前缀显示该行的行号
:set nonu
	
与 set nu 相反，为取消行号！
本模式下光标的移动：
（1）数值用来表示绝对行号 ：1跳转到第一行
（2）字符.表示光标所在的行号
（3）字符$表示正文最后一行的行号
（4）字符%表示所有行
（5）: + 5表示定位到当前行向下的第5行
（6）：$跳转到最后一行
/^that 代表行首是that符号  $尾部符号
5.其他相关知识
（1）关于备份文件
set nobackup禁止生成备份文件
set backup允许生成备份文件
set backupdir=/path/to/dir生成备份文件存放目录
（2）关于临时交换文件
vi编辑器不户丢失文件—临时文件.swp 存入缓存区的内容（在当前目录下就会存在）、
（2.1）若编辑文件第一次生成交换文件.swap 第二次.swo第三次.swn 然后是.swm依次类推
（2.2）vim -r查看所有swap文件
（2.3）vim -r filename 恢复文件，使用上次意外退出没有保存的修改，覆盖filename文件内容，最后使用rm命令删除交换文件
（2.4）防止生成swap文件 set noswapfile
（2.5）恢复生成swap文件 set swapfile
（2.6）设置临时交换文件的存在目录 ：set directory =/path/to/dir默认设置set updatetime=200
（3）关于undo文件
set noundofile
set undodir=/path/to/dir
6.区块选择
v字符选择
V行选择
ctrl V区块选择
7.多文件编辑
：files查看目录vim打开的所有文件
：n 编辑下一个文件
：N编辑上一个文件
8.多窗口功能
:sp[filenaame] 上下分割，当前文件分窗口同步编辑，或者在新窗口打开一个新文件filename
ctrl w + j将光标移动到下方的窗口
ctrl w + k将光标移动到上方的窗口
ctrl w + h l将光标移动到左边或者右边的窗口
：vsp垂直分割
退出：q当前的窗口
名称补全功能 
ctrl x ctrl n—利用目前正在编辑的文件内容作为关键词，予以补全
ctrl x ctrl f—利用目前的文件名作为关键词，予以补全
ctrl x ctrl o—以扩展名作为语法补充，以vim内建的关键词，予以补全
9.宏--执行宏的所有内容
命令模式下输入q<reg>(a-zA-Z0-9 37个寄存器之一)，启动宏录制
然后继续宁任何操作，包括模式间的切换
在命令行模式下输入q结束录制
使用@<reg>执行该宏
:help q
10.书签 命令模式下输入m<reg>制作书签
使用’<reg>’或者反单引号<reg>跳转到制定书签
：help m
11.其他
:g / 1\d /正则表达式查看10-19的内容
:g / 1\d /d正则表达式删除10-19的内容
help ：s查询帮助
12其他
插件--引入了新的包管理机制，未来会代替包管理器
vim支持插件的编写
配置文件为 ~/.vimrc  配置文件存放目录位置~/.vim
配色 ：colorscheme delek
自动缩进 help cindent/autoindent/smartindent   使用=命令济宁缩进
代码折叠 :help fold
13.环境设定
（1）运行中set命令设定
（2）通过环境变量进行设定 EXINIT=”set nu | syntax off”    export  EXINIT
          或者 只对当前运行有效 env EXINIT=”set nu | syntax off”  vi hello.txt
（3）全局配置文件/etc/vimrc 个人配置文件~/.vimrc或者~/.exrc
具体可以设置的内容查阅资料
echo $VIM查看当前使用的vim的版本内容
14.常见问题
中文编码
LANG=
exprot LANG
文本文件换行符ctrl +LF---windows  LF—unix
编码转换命令 iconv –list列表显示可以使用的编码方式
15.使用举例

    更改行号
    解决方案： :%s/ (\(\d\+\))/\=”(”.(submatch(1)+1).”)”/g
    s替换 (\(\d\+\))--查找的内容  (”.(submatch(1)+1).”)--替换的内容 g—全局替换
    查询的数字存储到寄存器中 submatch（1）代表存在寄存器中的数字 –正则表达式+内置函数实现
    -$-代表分割 实际是同一行的内容
    使用vi编辑器进行替换 查找换行、$、换行替换成\即可
    或者ddkjx dd删除当前行k向上一行 j-合并当前行x删除空格
    g/ - \$-/norm ddkjx
    连续插入30个等号  36i= esc
    多行开始插入// 使用虚拟块模式
    ctrl v  shift I 行首插入内容
    25i* esc
    16.打造vi编辑器件开发环境---vim插件的安装
    vim实用技巧—内容很深
    plug报错--安装插件模块vim-plug
    安装步骤：
    1）添加源sudo add-apt-repository ppa:neovim-ppa/stable
    2）sudo apt-get update 
    3)  sudo apt-get install neovim
    4)  deoplete需要neovim为0.3.0++
    NVIM v0.6.1—安装版本号
    配置步骤：

tracer@tracerX:~$ cd .config
tracer@tracerX:~/.config$ mkdir nvim
tracer@tracerX:~/.config$ cd nvim/
tracer@tracerX:~/.config/nvim$ ln -s ~/.vimrc init.vim
tracer@tracerX:~/.config/nvim$ ls -l
总用量 0
lrwxrwxrwx 1 tracer tracer 19 3月   5 19:55 init.vim -> /home/tracer/.vimrc
tracer@tracerX:~/.config/nvim$ 
cp plug.vim ~/.local/share/nvim/site/autoload/ 
安装插件
进入nvim编辑器，命令行输入Pluginstall
sudo apt-get install python-neovim
sudo apt-get install python3-neovim
查看vim替代族：update-alternatives –display vi
update-alternatives –config vi
----------------------------------chacpter6：BASH学习--------------------------------------
1.shell是一个应用程序，如同包裹着操作系统（一组软件，控制系统和管理系统的活动检测）能力的一层外壳，可以接受用户发出的命令，并调用系统核心能力来完成工作。
2./etc/shell查看系统的合法shell，可以使用
3.bash的功能—命令与文件补全，使用tab键补全
4.查询指令是否是bash的内建命令 type命令 builtin—内置命令，同时也是一个可执行文件
-a所有类型
-t参数 file-外部指令 alials—代称
5.shell的变量功能 文字、符号代表设定或者保留数据
echo显示变量的数值  variable=value给变量设置相应的数值（两边没有空格）
\--转义为普通字符
$()或者`可以完成动态给变量赋值的功能  $（）支持命令的嵌套
export将变量输出到环境中，导出的变量可以访问到--子进程只会支持父进程的环境变量，不会继承自定义变量
大写字母系统变量 小写—自定义变量
unset—取消变量
6.env查看当前shell的所有环境变量
shell环境变量—目前使用的shell 
LANG—语言设定 RANDOM—获取随机数
$--当前shell的pid，可以使用echo $$显示
locale -a查看当前系统支持的所有语言
locale查看当前使用的语言总类  usr lib locale     etc中查看配置文件
7.read shell 内置命令 从标准输入读内容到变量  read—完成交互操作--用户输入的操作
declare x 变量 将变量转换为环境变量
ulimit限制用户使用的系统资源【hsacfdltu】--对用户进行限制
8.变量内容的删除、替换等操作---可以使用if then来进行操作
echo $a—读取a变量的名字
echo ${a}er—添加er
echo$(var-word)  var is unset return word并且不改变变量的数值，如果已经设定返回var的值
echo$(var：-word)   var is unset  or null return word
echo$(var=word)没有设定，返回同时进行赋值
echo$(var+word) var设定则返回word，否则返回空，不设定变量的值
echo$(var##word) 删除word的最长匹配的字符串
echo$(var#word) 删除第一次word匹配的字符串
echo$(var%%word) 删除word的最长匹配的字符串（从右向左）
echo$(var：offset:length) offset开始length长度的字符串
$（#var）返回字符的长度
echo$(var/s/t)进行一个字符的替换
echo$(var//s/t)进行所有字符的替换
9.history有关历史记录的相关命令
（1）alias unalias
~/.bash_alias文件进行配置
（2）history -c 清除内容
-a 将指令添加到history files 
-r 读入历史命令到当前的shell中
-w 将history写入file文件中 bashhistory
使用！执行历史命令 ！！重复执行
（3）环境变量控制history的形态
重复命令不进行记录
shopt -s 进行设定  man -h –help寻找帮助手册
（4）如何为命令添加时间错的功能
在～/.bashrc中添加
HISTTIMEFORMAT=‘%F %T’
运行. ～/.bashrc 或者source ～/.bashrc
添加prompt——command始终存储命令，防止命令丢失
10.bash的其他知识与source命令
（1）路径与命令的搜索顺序
alias-》bash-》$path路径
（2）/etc/issues 本地登陆提示系统的提示信息\d 日期 \l端口\t本地时间
/etc/issue.net远端登陆系统的信息
/etc/motd其内部的信息可以被登陆者看到
（3）loginshell读取配置文件，启动shell需要完成登陆流程
non-启动子bash
（4）source读入环境配置文件的命令--在当前shell中来运行
shell内置命令，可以使用.来代替，可以将配置文件读如到当前的shell中
sh是脚本文件 +x增加可执行权限
./xxx.sh--子shell运行  . xxx.sh—父shell运行
11.终端设定stty 、set
stty -a列出终端参数
（1）intr interupt信号  kill删除目前命令行的所有文字 eof表示结束输入
stop停止目前屏幕的输出
stty erase ctrlH设置ctrlh进行字符的删除
（2）stty size显示端口的大小
echo $-显示目前的默认设定
（1）set -u显示不存在的变量时，会输出变量不存在
（2）set -x经常用来调试脚本    bash -x xxx.sh类似于set -x  bashXXX.sh
12.重定向 stdin0 stdout1 stderror2
2>代表标准错误输出 find home -name .bashrc 2>/dev/null
cmd1 && cmd2 cmd1执行成功返回0执行2
cmd1 || cmd2 cmd1执行错误执行2
管道不会理会错误输出，只输出标准输出
13.一些常用的命令
（1）cut制定分割符切割文本
选项参数：
-d 后面接分割字符，常与-f一起使用
-f依据-分割字符段将一段信息分为数段，用-f取出指定段
-c以字符的单位取出特定字符区间
last显示登陆的时间
（2）grep查找特定字符串，支持使用正则表达式
-a 以text搜寻二进制文件的数据
-i 忽略大小写
-n 输出行号
-v 反向选择
-c计算搜索到的字符串的字数
（3）sort排序
-f忽略大小写
-h忽略前面空格符
-u去重
-t 设定分割符，默认是tab键
-k 以制定区间来进行排序
（4）uniq去重
-l显示行数
-w显示多少字
-m显示字符数
（5）wc统计字符以及行数
-m显示字符数目
-l显示行数
-w显示多少字
（6）tee将数据流发送到文件和屏幕
-a以追加的方式写入文件
（7）tr 字符替换或者删除 translate
tr ‘[A-Z]’’[a-z]’大写转小 配合管道使用
tr -d ‘\r’删除\r
file查看文件类型
（8）col—用户过滤控制字符 常用将tab转换为空格
-x将tab转换为空格
-b 过滤所有的控制字符，包括rlf、hrlf
（9）join两个文件中，基于相同的数据，以行的方式拼接两个文件
-t 设定分割符，默认以空格符号分割数据
-i忽略大小写
（10）paste行对行的方式拼接，tab进行分割
-d设定分割符号
（11）expend将tab转换为空格
-t 默认使用8个空格号进行分割
cat查看文件ctrlI显示tab键
（12）split将大文件分割为小文件便于传输与存储
dd if= of= bs=1k count=2048产生一个2M的文件
参数：
-b 设定文件的切割大小
-l 以行数来进行分割
PREFIX 设定分割文件名的前缀
cat xa* >> another将分割的文件合并
（13）xargs  args-argument的意思，处理命令的参数，功能是读如stdin的数据，并且以空格符号或者换行符号进行分割，将读如内容分割为arguments
使用原因：对不支持管道的命令使用xargs为其提供stdin输入
-0：如果输入的stdin含有特殊字符，例如反引号`、反斜杠\、空格等字符时，xargs可以将它还原成一般字符。为xargs的默认选项。
-e ,-E ,--eof=：eof是end of file string的意思。flag可以是一个字符串或者是由空格分隔的多个字符串，当xargs分析到这个flag时，就会停止工作。见示例2。
-p：当每次执行一个argument的时候询问一次用户。
-n ：表示命令在执行的时候一次使用的argument的个数，由num指定，默认是用所有的参数。
-t：表示先打印命令，然后再执行。
-a :从文件中读入作为sdtin。
-i,-I：其中-I某些Linux版本不支持。将xargs的输出每一项参数，单独赋值给后面的命令，参数需要用{}代替。
-r:或者--no-run-if-empty,当xargs的输入为空的时候则停止xargs，不用再去执行后面的命令了，-r是xargs的默认选项。
-s :命令行的最大字符数，指的是xargs后面那个命令的最大命令行字符数,包括命令、空格和换行符。每个参数单独传入xargs后面的命令。见示例4。
-L ：设置标准输入中最大的行数作为命令每一次执行的参数。见示例5。
-d , --delimiter=: xargs处理标准输入默认是按换行符和空格作为分隔符，输出arguments的分隔符是空格，这里修改xargs处理标准输入时的分隔符。
-x：eXit的意思，主要是配合-s使用，当命令行字符数大于-s指定的数值时，退出xargs。
-P：修改最大的进程数，默认是1，为0时候为as many as it can。该选项比较少用，目前还不清楚该用法。
（14）减号命令
管道命令中为了省略文件名称，使用-代替stdin和stdout
---------------------------chacpter7：正则表达式与文件格式化处理------------------------------------
1.什么是正则表达式子RE
regular expression处理字符串的方法：通过特殊符号的辅助，帮助完成字符串的搜索/删除/替代等操作
basic RE     extend RE
同配符是shell提供的接口，正则表达式是字符串处理方式
（1）basic RE
语系对正则表达式有影响
LANG=c [A-Z]
LANG=zh_TW [A-Z]AbBcC…
一些预设定的特殊符号：
大量的unix命令也使用了正则表达式—grep等等
正则表达式的语法：
则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。
例如：

    runoo+b，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。 
    runoo*b，可以匹配 runob、runoob、runoooooob 等，* 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。 
    colou?r 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次或1次）。 

构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。
正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为"元字符"）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。
普通字符
普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。
ABC]
	
匹配 [...] 中的所有字符，例如 [aeiou] 匹配字符串 "google runoob taobao" 中所有的 e o u a 字母。
	
尝试一下 »
[^ABC]
	
匹配除了 [...] 中字符的所有字符，例如 [^aeiou] 匹配字符串 "google runoob taobao" 中除了 e o u a 字母的所有字母。
	
尝试一下 »
[A-Z]
	
[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。
	
尝试一下 »
.
	
匹配除换行符（\n、\r）之外的任何单个字符，相等于 [^\n\r]。
	
尝试一下 »
[\s\S]
	
匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。
	
尝试一下 »
\w
	
匹配字母、数字、下划线。等价于 [A-Za-z0-9_]
	
非打印字符
非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：
字符
	
描述
\cx
	
匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。
\f
	
匹配一个换页符。等价于 \x0c 和 \cL。
\n
	
匹配一个换行符。等价于 \x0a 和 \cJ。
\r
	
匹配一个回车符。等价于 \x0d 和 \cM。
\s
	
匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。
\S
	
匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\t
	
匹配一个制表符。等价于 \x09 和 \cI。
\v
	
匹配一个垂直制表符。等价于 \x0b 和 \cK。
特殊字符
所谓特殊字符，就是一些有特殊含义的字符，如上面说的 runoo*b 中的 *，简单的说就是表示任何字符串的意思。如果要查找字符串中的 * 符号，则需要对 * 进行转义，即在其前加一个 \，runo\*ob 匹配字符串 runo*ob。
许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符"转义"，即，将反斜杠字符\ 放在它们前面。下表列出了正则表达式中的特殊字符：
特别字符
	
描述
$
	
匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。
( )
	
标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。
*
	
匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。
+
	
匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。
.
	
匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。
[
	
标记一个中括号表达式的开始。要匹配 [，请使用 \[。
?
	
匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。
\
	
将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。
^
	
匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。
{
	
标记限定符表达式的开始。要匹配 {，请使用 \{。
|
	
指明两项之间的一个选择。要匹配 |，请使用 \|。
限定符
限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。
正则表达式的限定符有：
字符
	
描述
*
	
匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。
+
	
匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。
?
	
匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。
{n}
	
n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。
{n,}
	
n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。
{n,m}
	
m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。
以下正则表达式匹配一个正整数，[1-9]设置第一个数字不是 0，[0-9]* 表示任意多个数字：
/[1-9][0-9]*/
请注意，限定符出现在范围表达式之后。因此，它应用于整个范围表达式，在本例中，只指定从 0 到 9 的数字（包括 0 和 9）。
这里不使用 + 限定符，因为在第二个位置或后面的位置不一定需要有一个数字。也不使用 ? 字符，因为使用 ? 会将整数限制到只有两位数。
如果你想设置 0~99 的两位数，可以使用下面的表达式来至少指定一位但至多两位数字。
/[0-9]{1,2}/
上面的表达式的缺点是，只能匹配两位数字，而且可以匹配 0、00、01、10 99 的章节编号仍只匹配开头两位数字。
改进下，匹配 1~99 的正整数表达式如下：
/[1-9][0-9]?/
或
/[1-9][0-9]{0,1}/
* 和 + 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配。
例如，您可能搜索 HTML 文档，以查找在 h1 标签内的内容。HTML 代码如下：
<h1>RUNOOB-菜鸟教程</h1>
贪婪：下面的表达式匹配从开始小于符号 (<) 到关闭 h1 标记的大于符号 (>) 之间的所有内容。
/<.*>/
非贪婪：如果您只需要匹配开始和结束 h1 标签，下面的非贪婪表达式只匹配 <h1>。
/<.*?>/
也可以使用以下正则表达式来匹配 h1 标签，表达式则是：
/<\w+?>/
始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。
若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。
若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：
/^Chapter [1-9][0-9]{0,1}/
真正的章节标题不仅出现行的开始处，而且它还是该行中仅有的文本。它既出现在行首又出现在同一行的结尾。下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用。通过创建只匹配一行文本的开始和结尾的正则表达式，就可做到这一点。
/^Chapter [1-9][0-9]{0,1}$/
匹配单词边界稍有不同，但向正则表达式添加了很重要的能力。单词边界是单词和空格之间的位置。非单词边界是任何其他位置。下面的表达式匹配单词 Chapter 的开头三个字符，因为这三个字符出现在单词边界后面：
/\bCha/
\b 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。例如，下面的表达式匹配单词 Chapter 中的字符串 ter，因为它出现在单词边界的前面：
/ter\b/
下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt：
/\Bapt/
字符串 apt 出现在单词 Chapter 中的非单词边界处，但出现在单词 aptitude 中的单词边界处。对于 \B 非单词边界运算符，不可以匹配单词的开头或结尾，如果是下面的表达式，就不匹配 Chapter 中的 Cha：
\BCha
选择
用圆括号 () 将所有选择项括起来，相邻的选择项之间用 | 分隔。
() 表示捕获分组，() 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(n 是一个数字，表示第 n 个捕获组的内容)。
但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用 ?: 放在第一个选项前来消除这种副作用。
其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。
以下列出 ?=、?<=、?!、?<! 的使用区别
exp1(?=exp2)：查找 exp2 前面的 exp1。
​
添加图片注释，不超过 140 字（可选）
(?<=exp2)exp1：查找 exp2 后面的 exp1。
​
添加图片注释，不超过 140 字（可选）
exp1(?!exp2)：查找后面不是 exp2 的 exp1。
​
添加图片注释，不超过 140 字（可选）
(?<!exp2)exp1：查找前面不是 exp2 的 exp1。
​
添加图片注释，不超过 140 字（可选）
更多内容可以参考：正则表达式的先行断言(lookahead)和后行断言(lookbehind)
反向引用
对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。
可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。 
反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。以下面的句子为例：
Is is the cost of of gasoline going up up?
上面的句子很显然有多个重复的单词。如果能设计一种方法定位该句子，而不必查找每个单词的重复出现，那该有多好。下面的正则表达式使用单个子表达式来实现这一点：
实例
查找重复的单词：
var str = "Is is the cost of of gasoline going up up"; var patt1 = /\b([a-z]+) \1\b/ig; document.write(str.match(patt1));

捕获的表达式，正如 [a-z]+ 指定的，包括一个或多个字母。正则表达式的第二部分是对以前捕获的子匹配项的引用，即，单词的第二个匹配项正好由括号表达式匹配。\1 指定第一个子匹配项。
单词边界元字符确保只检测整个单词。否则，诸如 "is issued" 或 "this is" 之类的词组将不能正确地被此表达式识别。
正则表达式后面的全局标记 g 指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配。
表达式的结尾处的不区分大小写 i 标记指定不区分大小写。
多行标记指定换行符的两边可能出现潜在的匹配。
反向引用还可以将通用资源指示符 (URI) 分解为其组件。假定您想将下面的 URI 分解为协议（ftp、http 等等）、域地址和页/路径：
https://www.runoob.com:80/html/html-tutorial.html
下面的正则表达式提供该功能：
实例
输出所有匹配的数据：
var str = "https://www.runoob.com:80/html/html-tutorial.html"; var patt1 = /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/; arr = str.match(patt1); for (var i = 0; i < arr.length ; i++) { document.write(arr[i]); document.write("<br>"); }

第三行代码 str.match(patt1) 返回一个数组，实例中的数组包含 5 个元素，索引 0 对应的是整个字符串，索引 1 对应第一个匹配符（括号内），以此类推。
第一个括号子表达式捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。
第二个括号子表达式捕获地址的域地址部分。子表达式匹配非 : 和 / 之后的一个或多个字符。
第三个括号子表达式捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的零个或多个数字。只能重复一次该子表达式。
最后，第四个括号子表达式捕获 Web 地址指定的路径和 / 或页信息。该子表达式能匹配不包括 # 或空格字符的任何字符序列。
将正则表达式应用到上面的 URI，各子匹配项包含下面的内容：

    第一个括号子表达式包含 http 
    第二个括号子表达式包含 www.runoob.com 
    第三个括号子表达式包含 :80 
    第四个括号子表达式包含 /html/html-tutorial.html 

正则表达式 - 修饰符（标记）
标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。
标记不写在正则表达式里，标记位于表达式之外，格式如下：
/pattern/flags
下表列出了正则表达式常用的修饰符：
修饰符
	
含义
	
描述
i
	
ignore - 不区分大小写
	
将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。
g
	
global - 全局匹配
	
查找所有的匹配项。
m
	
multi line - 多行匹配
	
使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。
s
	
特殊字符圆点 . 中包含换行符 \n
	
默认情况下的圆点 . 是 匹配除换行符 \n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符 \n。
g 修饰符
g 修饰符可以查找字符串中所有的匹配项：
​
添加图片注释，不超过 140 字（可选）
实例
在字符串中查找 "runoob":
var str="Google runoob taobao runoob"; var n1=str.match(/runoob/); // 查找第一次匹配项 var n2=str.match(/runoob/g); // 查找所有匹配项

i 修饰符
i 修饰符为不区分大小写匹配，实例如下：
​
添加图片注释，不超过 140 字（可选）
实例
在字符串中查找 "runoob":
var str="Google runoob taobao RUNoob"; var n1=str.match(/runoob/g); // 区分大小写 var n2=str.match(/runoob/gi); // 不区分大小写

m 修饰符
m 修饰符可以使 ^ 和 $ 匹配一段文本中每行的开始和结束位置。
g 只匹配第一行，添加 m 之后实现多行。
​
添加图片注释，不超过 140 字（可选）
以下实例字符串中使用 \n 来换行：
实例
在字符串中查找 "runoob":
var str="runoobgoogle\ntaobao\nrunoobweibo"; var n1=str.match(/^runoob/g); // 匹配一个 var n2=str.match(/^runoob/gm); // 多行匹配

s 修饰符
默认情况下的圆点 . 是 匹配除换行符 \n 之外的任何字符，加上 s 之后, . 中包含换行符 \n。
​
添加图片注释，不超过 140 字（可选）
s 修饰符实例如下：
实例
在字符串中查找:
var str="google\nrunoob\ntaobao"; var n1=str.match(/google./); // 没有使用 s，无法匹配\n var n2=str.match(/runoob./s); // 使用 s，匹配\n
\(pattern\)将找到的串存入 标记寄存器
\pattern\不考虑大小写
=~模式匹配运算
$string = ~/pattern/表示对字符串$string用模式/pattern/进行匹配运算
！～：不相匹配运算符
常用的函数tr/xx/ss/ s//xx/aa/eg—进行字符串的替换操作
正则表达式 - 元字符
下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为：
字符
	
描述
\
	
将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。
^
	
匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。
$
	
匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。
*
	
匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。
+
	
匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。
?
	
匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 。? 等价于 {0,1}。
{n}
	
n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。
{n,}
	
n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。
{n,m}
	
m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。
?
	
当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。
.
	
匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用像"(.|\n)"的模式。
(pattern)
	
匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\(' 或 '\)'。
(?:pattern)会返回内容
	
匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。
(?=pattern)返回位置
	
正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，"Windows(?=95|98|NT|2000)"能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
(?!pattern)
	
正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如"Windows(?!95|98|NT|2000)"能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
(?<=pattern)向前查找并返回位置
	
反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，"(?<=95|98|NT|2000)Windows"能匹配"2000Windows"中的"Windows"，但不能匹配"3.1Windows"中的"Windows"。
(?<!pattern)
	
反向否定预查，与正向否定预查类似，只是方向相反。例如"(?<!95|98|NT|2000)Windows"能匹配"3.1Windows"中的"Windows"，但不能匹配"2000Windows"中的"Windows"。
x|y
	
匹配 x 或 y。例如，'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"。
[xyz]
	
字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。
[^xyz]
	
负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'、'l'、'i'、'n'。
[a-z]
	
字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。
[^a-z]
	
负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。
\b
	
匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
\B
	
匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。
\cx
	
匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。
\d
	
匹配一个数字字符。等价于 [0-9]。
\D
	
匹配一个非数字字符。等价于 [^0-9]。
\f
	
匹配一个换页符。等价于 \x0c 和 \cL。
\n
	
匹配一个换行符。等价于 \x0a 和 \cJ。
\r
	
匹配一个回车符。等价于 \x0d 和 \cM。
\s
	
匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
\S
	
匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\t
	
匹配一个制表符。等价于 \x09 和 \cI。
\v
	
匹配一个垂直制表符。等价于 \x0b 和 \cK。
\w
	
匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'。
\W
	
匹配非字母、数字、下划线。等价于 '[^A-Za-z0-9_]'。
\xn
	
匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。
\num
	
匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。
\n
	
标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。
\nm
	
标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。
\nml
	
如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。
\un
	
匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。
​
添加图片注释，不超过 140 字（可选）

正则表达式 - 运算符优先级
正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。
相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：
运算符
	
描述
\
	
转义符
(), (?:), (?=), []
	
圆括号和方括号
*, +, ?, {n}, {n,}, {n,m}
	
限定符
^, $, \任何元字符、任何字符
	
定位点和序列（即：位置和顺序）
|
	
替换，"或"操作字符具有高于替换运算符的优先级，使得"m|food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m|f)ood"。
正则表达式 - 匹配规则
基本模式匹配
一切从最基本的开始。模式，是正则表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。例如：
^once
这个模式包含一个特殊的字符 ^，表示该模式只匹配那些以 once 开头的字符串。例如该模式与字符串 "once upon a time" 匹配，与 "There once was a man from NewYork" 不匹配。正如如 ^ 符号表示开头一样，$ 符号用来匹配那些以给定模式结尾的字符串。
bucket$
这个模式与 "Who kept all of this cash in a bucket" 匹配，与 "buckets" 不匹配。字符 ^ 和 $ 同时使用时，表示精确匹配（字符串与模式一样）。例如：
^bucket$
只匹配字符串 "bucket"。如果一个模式不包括 ^ 和 $，那么它与任何包含该模式的字符串匹配。例如模式：
once
与字符串
There once was a man from NewYork
Who kept all of his cash in a bucket.
是匹配的。
在该模式中的字母 (o-n-c-e) 是字面的字符，也就是说，他们表示该字母本身，数字也是一样的。其他一些稍微复杂的字符，如标点符号和白字符（空格、制表符等），要用到转义序列。所有的转义序列都用反斜杠 \ 打头。制表符的转义序列是 \t。所以如果我们要检测一个字符串是否以制表符开头，可以用这个模式：
^\t 
类似的，用 \n 表示"新行"，\r 表示回车。其他的特殊符号，可以用在前面加上反斜杠，如反斜杠本身用 \\ 表示，句号 . 用 \. 表示，以此类推。
字符簇
在 INTERNET 的程序中，正则表达式通常用来验证用户的输入。当用户提交一个 FORM 以后，要判断输入的电话号码、地址、EMAIL 地址、信用卡号码等是否有效，用普通的基于字面的字符是不够的。
所以要用一种更自由的描述我们要的模式的办法，它就是字符簇。要建立一个表示所有元音字符的字符簇，就把所有的元音字符放在一个方括号里：
[AaEeIiOoUu]
这个模式与任何元音字符匹配，但只能表示一个字符。用连字号可以表示一个字符的范围，如：
[a-z] // 匹配所有的小写字母 
[A-Z] // 匹配所有的大写字母 
[a-zA-Z] // 匹配所有的字母 
[0-9] // 匹配所有的数字 
[0-9\.\-] // 匹配所有的数字，句号和减号 
[ \f\r\t\n] // 匹配所有的白字符
同样的，这些也只表示一个字符，这是一个非常重要的。如果要匹配一个由一个小写字母和一位数字组成的字符串，比如 "z2"、"t6" 或 "g7"，但不是 "ab2"、"r2d3" 或 "b52" 的话，用这个模式：
^[a-z][0-9]$
尽管 [a-z] 代表 26 个字母的范围，但在这里它只能与第一个字符是小写字母的字符串匹配。
前面曾经提到^表示字符串的开头，但它还有另外一个含义。当在一组方括号里使用 ^ 时，它表示"非"或"排除"的意思，常常用来剔除某个字符。还用前面的例子，我们要求第一个字符不能是数字：
^[^0-9][0-9]$
这个模式与 "&5"、"g7"及"-2" 是匹配的，但与 "12"、"66" 是不匹配的。下面是几个排除特定字符的例子：
[^a-z] //除了小写字母以外的所有字符 
[^\\\/\^] //除了(\)(/)(^)之外的所有字符 
[^\"\'] //除了双引号(")和单引号(')之外的所有字符
特殊字符 .(点，句号)在正则表达式中用来表示除了"新行"之外的所有字符。所以模式 ^.5$ 与任何两个字符的、以数字5结尾和以其他非"新行"字符开头的字符串匹配。模式 . 可以匹配任何字符串，换行符（\n、\r）除外。
PHP的正则表达式有一些内置的通用字符簇，列表如下：
字符簇
	
描述
[[:alpha:]]
	
任何字母
[[:digit:]]
	
任何数字
[[:alnum:]]
	
任何字母和数字
[[:space:]]
	
任何空白字符
[[:upper:]]
	
任何大写字母
[[:lower:]]
	
任何小写字母
[[:punct:]]
	
任何标点符号
[[:xdigit:]]
	
任何16进制的数字，相当于[0-9a-fA-F]
确定重复出现
到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。
字符簇
	
描述
^[a-zA-Z_]$
	
所有的字母和下划线
^[[:alpha:]]{3}$
	
所有的3个字母的单词
^a$
	
字母a
^a{4}$
	
aaaa
^a{2,4}$
	
aa,aaa或aaaa
^a{1,3}$
	
a,aa或aaa
^a{2,}$
	
包含多于两个a的字符串
^a{2,}
	
如：aardvark和aaab，但apple不行
a{2,}
	
如：baad和aaa，但Nantucket不行
\t{2}
	
两个制表符
.{2}
	
所有的两个字符
这些例子描述了花括号的三种不同的用法。一个数字 {x} 的意思是前面的字符或字符簇只出现x次 ；一个数字加逗号 {x,} 的意思是前面的内容出现x或更多的次数 ；两个数字用逗号分隔的数字 {x,y} 表示 前面的内容至少出现x次，但不超过y次。我们可以把模式扩展到更多的单词或数字：
^[a-zA-Z0-9_]{1,}$      // 所有包含一个以上的字母、数字或下划线的字符串 
^[1-9][0-9]{0,}$        // 所有的正整数 
^\-{0,1}[0-9]{1,}$      // 所有的整数 
^[-]?[0-9]+\.?[0-9]+$   // 所有的浮点数
最后一个例子不太好理解，是吗？这么看吧：以一个可选的负号 ([-]?) 开头 (^)、跟着1个或更多的数字([0-9]+)、和一个小数点(\.)再跟上1个或多个数字([0-9]+)，并且后面没有其他任何东西($)。下面你将知道能够使用的更为简单的方法。
特殊字符 ? 与 {0,1} 是相等的，它们都代表着： 0个或1个前面的内容 或 前面的内容是可选的 。所以刚才的例子可以简化为：
^\-?[0-9]{1,}\.?[0-9]{1,}$
特殊字符 * 与 {0,} 是相等的，它们都代表着 0 个或多个前面的内容 。最后，字符 + 与 {1,} 是相等的，表示 1 个或多个前面的内容 ，所以上面的4个例子可以写成：
^[a-zA-Z0-9_]+$      // 所有包含一个以上的字母、数字或下划线的字符串 
^[1-9][0-9]*$        // 所有的正整数 
^\-?[0-9]+$          // 所有的整数 
^[-]?[0-9]+(\.[0-9]+)?$ // 所有的浮点数
当然这并不能从技术上降低正则表达式的复杂性，但可以使它们更容易阅读。
简单表达式
正则表达式的最简单形式是在搜索字符串中匹配其本身的单个普通字符。例如，单字符模式，如 A，不论出现在搜索字符串中的何处，它总是匹配字母 A。下面是一些单字符正则表达式模式的示例：
/a/
/7/
/M/
可以将许多单字符组合起来以形成大的表达式。例如，以下正则表达式组合了单字符表达式：a、7 和 M。
/a7M/
请注意，没有串联运算符。只须在一个字符后面键入另一个字符。
字符匹配
句点 (.) 匹配字符串中的各种打印或非打印字符，只有一个字符例外。这个例外就是换行符 (\n)。下面的正则表达式匹配 aac、abc、acc、adc 等等，以及 a1c、a2c、a-c 和 a#c：
/a.c/
若要匹配包含文件名的字符串，而句点 (.) 是输入字符串的组成部分，请在正则表达式中的句点前面加反斜杠 (\) 字符。举例来说明，下面的正则表达式匹配 filename.ext：
/filename\.ext/
这些表达式只让您匹配"任何"单个字符。可能需要匹配列表中的特定字符组。例如，可能需要查找用数字表示的章节标题（Chapter 1、Chapter 2 等等）。
中括号表达式
若要创建匹配字符组的一个列表，请在方括号（[ 和 ]）内放置一个或更多单个字符。当字符括在中括号内时，该列表称为"中括号表达式"。与在任何别的位置一样，普通字符在中括号内表示其本身，即，它在输入文本中匹配一次其本身。大多数特殊字符在中括号表达式内出现时失去它们的意义。不过也有一些例外，如：

    如果 ] 字符不是第一项，它结束一个列表。若要匹配列表中的 ] 字符，请将它放在第一位，紧跟在开始 [ 后面。 
    \ 字符继续作为转义符。若要匹配 \ 字符，请使用 \\。 

括在中括号表达式中的字符只匹配处于正则表达式中该位置的单个字符。以下正则表达式匹配 Chapter 1、Chapter 2、Chapter 3、Chapter 4 和 Chapter 5：
/Chapter [12345]/
请注意，单词 Chapter 和后面的空格的位置相对于中括号内的字符是固定的。中括号表达式指定的只是匹配紧跟在单词 Chapter 和空格后面的单个字符位置的字符集。这是第九个字符位置。
若要使用范围代替字符本身来表示匹配字符组，请使用连字符 (-) 将范围中的开始字符和结束字符分开。单个字符的字符值确定范围内的相对顺序。下面的正则表达式包含范围表达式，该范围表达式等效于上面显示的中括号中的列表。
/Chapter [1-5]/
当以这种方式指定范围时，开始值和结束值两者都包括在范围内。注意，还有一点很重要，按 Unicode 排序顺序，开始值必须在结束值的前面。
若要在中括号表达式中包括连字符，请采用下列方法之一：

    用反斜杠将它转义： 
    [\-]
    将连字符放在中括号列表的开始或结尾。下面的表达式匹配所有小写字母和连字符： 
    [-a-z]
    [a-z-]
    创建一个范围，在该范围中，开始字符值小于连字符，而结束字符值等于或大于连字符。下面的两个正则表达式都满足这一要求： 

[!--]
[!-~]
若要查找不在列表或范围内的所有字符，请将插入符号 (^) 放在列表的开头。如果插入字符出现在列表中的其他任何位置，则它匹配其本身。下面的正则表达式匹配1、2、3、4 或 5 之外的任何数字和字符：
/Chapter [^12345]/
在上面的示例中，表达式在第九个位置匹配 1、2、3、4 或 5 之外的任何数字和字符。这样，例如，Chapter 7 就是一个匹配项，Chapter 9 也是一个匹配项。
上面的表达式可以使用连字符 (-) 来表示：
/Chapter [^1-5]/
中括号表达式的典型用途是指定任何大写或小写字母或任何数字的匹配。下面的表达式指定这样的匹配：
/[A-Za-z0-9]/
替换和分组
替换使用 | 字符来允许在两个或多个替换选项之间进行选择。例如，可以扩展章节标题正则表达式，以返回比章标题范围更广的匹配项。但是，这并不象您可能认为的那样简单。替换匹配 | 字符任一侧最大的表达式。
您可能认为，下面的表达式匹配出现在行首和行尾、后面跟一个或两个数字的 Chapter 或 Section：
/^Chapter|Section [1-9][0-9]{0,1}$/
很遗憾，上面的正则表达式要么匹配行首的单词 Chapter，要么匹配行尾的单词 Section 及跟在其后的任何数字。如果输入字符串是 Chapter 22，那么上面的表达式只匹配单词 Chapter。如果输入字符串是 Section 22，那么该表达式匹配 Section 22。
若要使正则表达式更易于控制，可以使用括号来限制替换的范围，即，确保它只应用于两个单词 Chapter 和 Section。但是，括号也用于创建子表达式，并可能捕获它们以供以后使用，这一点在有关反向引用的那一节讲述。通过在上面的正则表达式的适当位置添加括号，就可以使该正则表达式匹配 Chapter 1 或 Section 3。
下面的正则表达式使用括号来组合 Chapter 和 Section，以便表达式正确地起作用：
/^(Chapter|Section) [1-9][0-9]{0,1}$/
尽管这些表达式正常工作，但 Chapter|Section 周围的括号还将捕获两个匹配字中的任一个供以后使用。由于在上面的表达式中只有一组括号，因此，只有一个被捕获的"子匹配项"。
在上面的示例中，您只需要使用括号来组合单词 Chapter 和 Section 之间的选择。若要防止匹配被保存以备将来使用，请在括号内正则表达式模式之前放置 ?:。下面的修改提供相同的能力而不保存子匹配项：
/^(?:Chapter|Section) [1-9][0-9]{0,1}$/
除 ?: 元字符外，两个其他非捕获元字符创建被称为"预测先行"匹配的某些内容。正向预测先行使用 ?= 指定，它匹配处于括号中匹配正则表达式模式的起始点的搜索字符串。反向预测先行使用 ?! 指定，它匹配处于与正则表达式模式不匹配的字符串的起始点的搜索字符串。
例如，假设您有一个文档，该文档包含指向 Windows 3.1、Windows 95、Windows 98 和 Windows NT 的引用。再进一步假设，您需要更新该文档，将指向 Windows 95、Windows 98 和 Windows NT 的所有引用更改为 Windows 2000。下面的正则表达式（这是一个正向预测先行的示例）匹配 Windows 95、Windows 98 和 Windows NT：
/Windows(?=95 |98 |NT )/
找到一处匹配后，紧接着就在匹配的文本（不包括预测先行中的字符）之后搜索下一处匹配。例如，如果上面的表达式匹配 Windows 98，将在 Windows 之后而不是在 98 之后继续搜索。
其他示例
下面列出一些正则表达式示例：
正则表达式
	
描述
/\b([a-z]+) \1\b/gi
	
一个单词连续出现的位置。
/(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/
	
匹配一个 URL 解析为协议、域、端口及相对路径。
/^(?:Chapter|Section) [1-9][0-9]{0,1}$/
	
定位章节的位置。
/[-a-z]/
	
a 至 z 共 26个 字母再加一个 - 号。
/ter\b/
	
可匹配 chapter，而不能匹配 terminal。
/\Bapt/
	
可匹配 chapter，而不能匹配 aptitude。
/Windows(?=95 |98 |NT )/
	
可匹配 Windows95 或 Windows98 或 WindowsNT，当找到一个匹配后，从 Windows 后面开始进行下一次的检索匹配。
/^\s*$/
	
匹配空行。
/\d{2}-\d{5}/
	
验证由两位数字、一个连字符再加 5 位数字组成的 ID 号。
<[a-zA-Z]+.*?>([\s\S]*?)
	
匹配 HTML 标记。
正则表达式
	
描述
hello
	
匹配 {hello}
gray|grey
	
匹配 {gray, grey}
gr(a|e)y
	
匹配 {gray, grey}
gr[ae]y
	
匹配 {gray, grey}
b[aeiou]bble
	
匹配 {babble, bebble, bibble, bobble, bubble}
[b-chm-pP]at|ot
	
匹配 {bat, cat, hat, mat, nat, oat, pat, Pat, ot}
colou?r
	
匹配 {color, colour}
rege(x(es)?|xps?)
	
匹配 {regex, regexes, regexp, regexps}
go*gle
	
匹配 {ggle, gogle, google, gooogle, goooogle, ...}
go+gle
	
匹配 {gogle, google, gooogle, goooogle, ...}
g(oog)+le
	
匹配 {google, googoogle, googoogoogle, googoogoogoogle, ...}
z{3}
	
匹配 {zzz}
z{3,6}
	
匹配 {zzz, zzzz, zzzzz, zzzzzz}
z{3,}
	
匹配 {zzz, zzzz, zzzzz, ...}
[Bb]rainf\*\*k
	
匹配 {Brainf**k, brainf**k}
\d
	
匹配 {0,1,2,3,4,5,6,7,8,9}
1\d{10}
	
匹配 11 个数字，以 1 开头
[2-9]|[12]\d|3[0-6]
	
匹配 2 到 36 范围内的整数
Hello\nworld
	
匹配 Hello 后跟换行符，后跟 world
\d+(\.\d\d)?
	
包含一个正整数或包含两位小数位的浮点数。
[^*@#]
	
排除 *、@ 、# 三个特色符号
//[^\r\n]*[\r\n]
	
匹配 // 开头的注释
^dog
	
匹配以 "dog" 开始
dog$
	
匹配以 "dog" 结尾
^dog$
	
is exactly "dog"
常用正则表达式
一、校验数字的表达式

    数字：^[0-9]*$
    n位的数字：^\d{n}$
    至少n位的数字：^\d{n,}$
    m-n位的数字：^\d{m,n}$
    零和非零开头的数字：^(0|[1-9][0-9]*)$
    非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(\.[0-9]{1,2})?$
    带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})$
    正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$
    有两位小数的正实数：^[0-9]+(\.[0-9]{2})?$
    有1~3位小数的正实数：^[0-9]+(\.[0-9]{1,3})?$
    非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$
    非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$
    非负整数：^\d+$ 或 ^[1-9]\d*|0$
    非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$
    非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$
    非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$
    正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$
    负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$
    浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$

校验字符的表达式

    汉字：^[\u4e00-\u9fa5]{0,}$
    英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$
    长度为3-20的所有字符：^.{3,20}$
    由26个英文字母组成的字符串：^[A-Za-z]+$
    由26个大写英文字母组成的字符串：^[A-Z]+$
    由26个小写英文字母组成的字符串：^[a-z]+$
    由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$
    由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$
    中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$
    中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$
    可以输入含有^%&',;=?$\"等字符：[^%&',;=?$\x22]+
    禁止输入含有~的字符：[^~\x22]+

三、特殊需求表达式

    Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
    域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+\.?
    InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$
    手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|4|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$
    电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 
    国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 
    电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\d{11})|^((\d{7,8})|(\d{4}|\d{3})-(\d{7,8})|(\d{4}|\d{3})-(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1})|(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1}))$) 
    身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)
    帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
    密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$ 
    强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$ 
    强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 
    日期格式：^\d{4}-\d{1,2}-\d{1,2}
    一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$
    一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 
    钱的输入格式：

    有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$ 
    这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 
    一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 
    这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 
    必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]{2})?$ 
    这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 
    这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 
    1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 
    备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里


    xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$
    中文字符的正则表达式：[\u4e00-\u9fa5]
    双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
    空白行的正则表达式：\n\s*\r (可以用来删除空白行)
    HTML标记的正则表达式：<(\S*?)[^>]*>.*?|<.*? /> ( 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
    腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)
    中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)
    IPv4地址：((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})){3}

二、grep家族概述
grep命令在一个文件中搜索指定的字符串，基本的语法格式为：
grep [OPTIONS] [-e] ‘pattern’ [filenames]
fgrep是一个快速版本，不允许使用正则表达式，egrep不支持标记表达式/或者/（
-n 显示匹配的行号  -v 显示非匹配行 -r递归匹配 -i忽略字母的大小写
agrep进行模糊查找 ngrep进行网路层数据查找pdfgrep用于搜索pdf文件中的模式
ack是grep的一个可选替代品，可以对匹配字符串进行高亮显示
sgrep用于搜索结构化的模式，xgrep专门针对xml文件的搜索工具
[]表示内部内容 \b完整单词\>代表完整单词
基本正则表达时与扩展正则表达式的区别—一般看到扩展表达式并进行使用，具体解决时在考虑即可。
alnum—英文字母和数字，lalpha英文字母
dmesg系统启动过程中的所有信息
两个正则表达式的示例：
？=向前看 某种解释的开有
？: 向后看
? < 
三、sed工具 string edit流编辑器
流—具有特殊属性的动态序列元素，流中所有的元素都具有相同的数据类型，流中元素的个数被称为数据的长度，对流可以进行读写操作
所有行数默认输出，-n取消默认输出 d代表删除命令
s#6#88#g #进行划分
可以同时进行多个操作 -e  
-w写入一个新的文件
-a插入新的内容
y替换操作
5q输出5行并退出
h保存到缓冲区 x把缓冲区的内容进行交换
Linux sed 命令是利用脚本来处理文本文件。
sed 可依照脚本的指令来处理、编辑文本文件。
Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。
语法
sed [-hnV][-e<script>][-f<script文件>][文本文件]
参数说明：

    -e<script>或--expression=<script> 以选项中指定的script来处理输入的文本文件。 
    -f<script文件>或--file=<script文件> 以选项中指定的script文件来处理输入的文本文件。 
    -h或--help 显示帮助。 
    -n或--quiet或--silent 仅显示script处理后的结果。 
    -V或--version 显示版本信息。 
    -i直接修改文件内容，而非处理完毕后由屏幕输出

动作说明：

    a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
    c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
    d ：删除，因为是删除啊，所以 d 后面通常不接任何东东；
    i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
    p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～
    s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！ 

实例
在testfile文件的第四行后添加一行，并将结果输出到标准输出，在命令行提示符下输入如下命令： 
sed -e 4a\newLine testfile 
首先查看testfile中的内容如下：
$ cat testfile #查看testfile 中的内容  
HELLO LINUX!  
Linux is a free unix-type opterating system.  
This is a linux testfile!  
Linux test 
使用sed命令后，输出结果如下：
$ sed -e 4a\newline testfile #使用sed 在第四行后添加新字符串  
HELLO LINUX! #testfile文件原有的内容  
Linux is a free unix-type opterating system.  
This is a linux testfile!  
Linux test  
newline 
以行为单位的新增/删除
将 /etc/passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除！
[root@www ~]# nl /etc/passwd | sed '2,5d'
1 root:x:0:0:root:/root:/bin/bash
6 sync:x:5:0:sync:/sbin:/bin/sync
7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
.....(后面省略).....
sed 的动作为 '2,5d' ，那个 d 就是删除！因为 2-5 行给他删除了，所以显示的数据就没有 2-5 行罗～ 另外，注意一下，原本应该是要下达 sed -e 才对，没有 -e 也行啦！同时也要注意的是， sed 后面接的动作，请务必以 '' 两个单引号括住喔！ 
只要删除第 2 行
nl /etc/passwd | sed '2d' 
要删除第 3 到最后一行
nl /etc/passwd | sed '3,$d' 
在第二行后(亦即是加在第三行)加上『drink tea?』字样！
[root@www ~]# nl /etc/passwd | sed '2a drink tea'
1 root:x:0:0:root:/root:/bin/bash
2 bin:x:1:1:bin:/bin:/sbin/nologin
drink tea
3 daemon:x:2:2:daemon:/sbin:/sbin/nologin
.....(后面省略).....
那如果是要在第二行前
nl /etc/passwd | sed '2i drink tea' 
如果是要增加两行以上，在第二行后面加入两行字，例如 Drink tea or ..... 与 drink beer?
[root@www ~]# nl /etc/passwd | sed '2a Drink tea or ......\
> drink beer ?'
1 root:x:0:0:root:/root:/bin/bash
2 bin:x:1:1:bin:/bin:/sbin/nologin
Drink tea or ......
drink beer ?
3 daemon:x:2:2:daemon:/sbin:/sbin/nologin
.....(后面省略).....
每一行之间都必须要以反斜杠『 \ 』来进行新行的添加喔！所以，上面的例子中，我们可以发现在第一行的最后面就有 \ 存在。
以行为单位的替换与显示
将第2-5行的内容取代成为『No 2-5 number』呢？
[root@www ~]# nl /etc/passwd | sed '2,5c No 2-5 number'
1 root:x:0:0:root:/root:/bin/bash
No 2-5 number
6 sync:x:5:0:sync:/sbin:/bin/sync
.....(后面省略).....
透过这个方法我们就能够将数据整行取代了！ 
仅列出 /etc/passwd 文件内的第 5-7 行
[root@www ~]# nl /etc/passwd | sed -n '5,7p'
5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
6 sync:x:5:0:sync:/sbin:/bin/sync
7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
可以透过这个 sed 的以行为单位的显示功能， 就能够将某一个文件内的某些行号选择出来显示。 
数据的搜寻并显示
搜索 /etc/passwd有root关键字的行
nl /etc/passwd | sed '/root/p'
1  root:x:0:0:root:/root:/bin/bash
1  root:x:0:0:root:/root:/bin/bash
2  daemon:x:1:1:daemon:/usr/sbin:/bin/sh
3  bin:x:2:2:bin:/bin:/bin/sh
4  sys:x:3:3:sys:/dev:/bin/sh
5  sync:x:4:65534:sync:/bin:/bin/sync
....下面忽略 
如果root找到，除了输出所有行，还会输出匹配行。
使用-n的时候将只打印包含模板的行。
nl /etc/passwd | sed -n '/root/p'
1  root:x:0:0:root:/root:/bin/bash
数据的搜寻并删除
删除/etc/passwd所有包含root的行，其他行输出
nl /etc/passwd | sed  '/root/d'
2  daemon:x:1:1:daemon:/usr/sbin:/bin/sh
3  bin:x:2:2:bin:/bin:/bin/sh
....下面忽略
#第一行的匹配root已经删除了
数据的搜寻并执行命令
搜索/etc/passwd,找到root对应的行，执行后面花括号中的一组命令，每个命令之间用分号分隔，这里把bash替换为blueshell，再输出这行：
nl /etc/passwd | sed -n '/root/{s/bash/blueshell/;p;q}'    
1  root:x:0:0:root:/root:/bin/blueshell
最后的q是退出。
数据的搜寻并替换
除了整行的处理模式之外， sed 还可以用行为单位进行部分数据的搜寻并取代。基本上 sed 的搜寻与替代的与 vi 相当的类似！他有点像这样：
sed 's/要被取代的字串/新的字串/g'
先观察原始信息，利用 /sbin/ifconfig 查询 IP
[root@www ~]# /sbin/ifconfig eth0
eth0 Link encap:Ethernet HWaddr 00:90:CC:A6:34:84
inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0
inet6 addr: fe80::290:ccff:fea6:3484/64 Scope:Link
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
.....(以下省略).....
本机的ip是192.168.1.100。
将 IP 前面的部分予以删除
[root@www ~]# /sbin/ifconfig eth0 | grep 'inet addr' | sed 's/^.*addr://g'
192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0
接下来则是删除后续的部分，亦即： 192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0 
将 IP 后面的部分予以删除
[root@www ~]# /sbin/ifconfig eth0 | grep 'inet addr' | sed 's/^.*addr://g' | sed 's/Bcast.*$//g'
192.168.1.100
多点编辑
一条sed命令，删除/etc/passwd第三行到末尾的数据，并把bash替换为blueshell
nl /etc/passwd | sed -e '3,$d' -e 's/bash/blueshell/'
1  root:x:0:0:root:/root:/bin/blueshell
2  daemon:x:1:1:daemon:/usr/sbin:/bin/sh
-e表示多点编辑，第一个编辑命令删除/etc/passwd第三行到末尾的数据，第二条命令搜索bash替换为blueshell。
直接修改文件内容(危险动作)
sed 可以直接修改文件的内容，不必使用管道命令或数据流重导向！ 不过，由於这个动作会直接修改到原始的文件，所以请你千万不要随便拿系统配置来测试！ 我们还是使用文件 regular_express.txt 文件来测试看看吧！
regular_express.txt 文件内容如下：
[root@www ~]# cat regular_express.txt 
runoob.
google.
taobao.
facebook.
zhihu-
weibo-
利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 ! 
[root@www ~]# sed -i 's/\.$/\!/g' regular_express.txt
[root@www ~]# cat regular_express.txt 
runoob!
google!
taobao!
facebook!
zhihu-
weibo-
:q:q 
利用 sed 直接在 regular_express.txt 最后一行加入 # This is a test: 
[root@www ~]# sed -i '$a # This is a test' regular_express.txt
[root@www ~]# cat regular_express.txt 
runoob!
google!
taobao!
facebook!
zhihu-
weibo-
# This is a test
由於 $ 代表的是最后一行，而 a 的动作是新增，因此该文件最后新增 # This is a test！ 
sed 的 -i 选项可以直接修改文件内容，这功能非常有帮助！举例来说，如果你有一个 100 万行的文件，你要在第 100 行加某些文字，此时使用 vim 可能会疯掉！因为文件太大了！那怎办？就利用 sed 啊！透过 sed 直接修改/取代的功能，你甚至不需要使用 vim 去修订！
四、文件的格式化与处理
1.格式化打印printf
type -a print查看命令类型
\a输出警告生 \b退格 \V垂直的tab
2.awk
AWK 是一种处理文本文件的语言，是一个强大的文本分析工具--一种变成语言
之所以叫 AWK 是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。
每个字段使用$来表示$0 $1等等
begin第一条记录被读取之前匹配，end；最后一条记录处理完成之后匹配
/模式1/模式2 action—类似与sed命令
awk提供了很多的串函数 sub gsub函数等
语法
awk [选项参数] 'script' var=value file(s)
或
awk [选项参数] -f scriptfile var=value file(s)
选项参数说明：

    -F fs or --field-separator fs
    指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。 
    -v var=value or --asign var=value
    赋值一个用户定义变量。 
    -f scripfile or --file scriptfile
    从脚本文件中读取awk命令。 
    -mf nnn and -mr nnn
    对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。 
    -W compact or --compat, -W traditional or --traditional
    在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。 
    -W copyleft or --copyleft, -W copyright or --copyright
    打印简短的版权信息。 
    -W help or --help, -W usage or --usage
    打印全部awk选项和每个选项的简短说明。 
    -W lint or --lint
    打印不能向传统unix平台移植的结构的警告。 
    -W lint-old or --lint-old
    打印关于不能向传统unix平台移植的结构的警告。 
    -W posix
    打开兼容模式。但有以下限制，不识别：/x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符**和**=不能代替^和^=；fflush无效。 
    -W re-interval or --re-inerval
    允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。 
    -W source program-text or --source program-text
    使用program-text作为源代码，可与-f命令混用。 
    -W version or --version
    打印bug报告信息的版本。

基本用法
log.txt文本内容如下：
2 this is a test
3 Are you like awk
This's a test
10 There are orange,apple,mongo
用法一：
awk '{[pattern] action}' {filenames}   # 行匹配语句 awk '' 只能用单引号
实例：
# 每行按空格或TAB分割，输出文本中的1、4项
 $ awk '{print $1,$4}' log.txt
 ---------------------------------------------
 2 a
 3 like
 This's
 10 orange,apple,mongo
 # 格式化输出
 $ awk '{printf "%-8s %-10s\n",$1,$4}' log.txt
 ---------------------------------------------
 2        a
 3        like
 This's
 10       orange,apple,mongo
用法二：
awk -F  #-F相当于内置变量FS, 指定分割字符
实例：
# 使用","分割
 $  awk -F, '{print $1,$2}'   log.txt
 ---------------------------------------------
 2 this is a test
 3 Are you like awk
 This's a test
 10 There are orange apple
 # 或者使用内建变量
 $ awk 'BEGIN{FS=","} {print $1,$2}'     log.txt
 ---------------------------------------------
 2 this is a test
 3 Are you like awk
 This's a test
 10 There are orange apple
 # 使用多个分隔符.先使用空格分割，然后对分割结果再使用","分割
 $ awk -F '[ ,]'  '{print $1,$2,$5}'   log.txt
 ---------------------------------------------
 2 this test
 3 Are awk
 This's a
 10 There apple
用法三：
awk -v  # 设置变量
实例：
 $ awk -va=1 '{print $1,$1+a}' log.txt
 ---------------------------------------------
 2 3
 3 4
 This's 1
 10 11
 $ awk -va=1 -vb=s '{print $1,$1+a,$1b}' log.txt
 ---------------------------------------------
 2 3 2s
 3 4 3s
 This's 1 This'ss
 10 11 10s
用法四：
awk -f {awk脚本} {文件名}
实例：
 $ awk -f cal.awk log.txt
运算符
运算符
	
描述
= += -= *= /= %= ^= **=
	
赋值
?:
	
C条件表达式
||
	
逻辑或
&&
	
逻辑与
~ 和 !~
	
匹配正则表达式和不匹配正则表达式
< <= > >= != ==
	
关系运算符
空格
	
连接
+ -
	
加，减
* / %
	
乘，除与求余
+ - !
	
一元加，减和逻辑非
^ ***
	
求幂
++ --
	
增加或减少，作为前缀或后缀
$
	
字段引用
in
	
数组成员
过滤第一列大于2的行 
$ awk '$1>2' log.txt    #命令
#输出
3 Are you like awk
This's a test
10 There are orange,apple,mongo
过滤第一列等于2的行
$ awk '$1==2 {print $1,$3}' log.txt    #命令
#输出
2 is
过滤第一列大于2并且第二列等于'Are'的行
$ awk '$1>2 && $2=="Are" {print $1,$2,$3}' log.txt    #命令
#输出
3 Are you
内建变量
变量
	
描述
$n
	
当前记录的第n个字段，字段间由FS分隔
$0
	
完整的输入记录
ARGC
	
命令行参数的数目
ARGIND
	
命令行中当前文件的位置(从0开始算)
ARGV
	
包含命令行参数的数组
CONVFMT
	
数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组
ERRNO
	
最后一个系统错误的描述
FIELDWIDTHS
	
字段宽度列表(用空格键分隔)
FILENAME
	
当前文件名
FNR
	
各文件分别计数的行号
FS
	
字段分隔符(默认是任何空格) field secret 分割符
IGNORECASE
	
如果为真，则进行忽略大小写的匹配
NF
	
一条记录的字段的数目 代表分割的字段的数目
NR
	
已经读出的记录数，就是行号，从1开始
OFMT
	
数字的输出格式(默认值是%.6g)
OFS
	
输出字段分隔符，默认值与输入字段分隔符一致。
ORS
	
输出记录分隔符(默认值是一个换行符) 使用printf不会自动输出ors，必须自己在format中使用\n来显示的产生
RLENGTH
	
由match函数所匹配的字符串的长度
RS
	
记录分隔符(默认是一个换行符)
RSTART
	
由match函数所匹配的字符串的第一个位置
SUBSEP
	
数组下标分隔符(默认值是/034)
$ awk 'BEGIN{printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n","FILENAME","ARGC","FNR","FS","NF","NR","OFS","ORS","RS";printf "---------------------------------------------\n"} {printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n",FILENAME,ARGC,FNR,FS,NF,NR,OFS,ORS,RS}'  log.txt
FILENAME ARGC  FNR   FS   NF   NR  OFS  ORS   RS
---------------------------------------------
log.txt    2    1         5    1
log.txt    2    2         5    2
log.txt    2    3         3    3
log.txt    2    4         4    4
$ awk -F\' 'BEGIN{printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n","FILENAME","ARGC","FNR","FS","NF","NR","OFS","ORS","RS";printf "---------------------------------------------\n"} {printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n",FILENAME,ARGC,FNR,FS,NF,NR,OFS,ORS,RS}'  log.txt
FILENAME ARGC  FNR   FS   NF   NR  OFS  ORS   RS
---------------------------------------------
log.txt    2    1    '    1    1
log.txt    2    2    '    1    2
log.txt    2    3    '    2    3
log.txt    2    4    '    1    4
# 输出顺序号 NR, 匹配文本行号
$ awk '{print NR,FNR,$1,$2,$3}' log.txt
---------------------------------------------
1 1 2 this is
2 2 3 Are you
3 3 This's a test
4 4 10 There are
# 指定输出分割符
$  awk '{print $1,$2,$5}' OFS=" $ "  log.txt
---------------------------------------------
2 $ this $ test
3 $ Are $ awk
This's $ a $
10 $ There $
使用正则，字符串匹配
# 输出第二列包含 "th"，并打印第二列与第四列
$ awk '$2 ~ /th/ {print $2,$4}' log.txt
---------------------------------------------
this a
~ 表示模式开始。// 中是模式。
# 输出包含 "re" 的行
$ awk '/re/ ' log.txt
---------------------------------------------
3 Are you like awk
10 There are orange,apple,mongo
忽略大小写 
$ awk 'BEGIN{IGNORECASE=1} /this/' log.txt
---------------------------------------------
2 this is a test
This's a test
模式取反
$ awk '$2 !~ /th/ {print $2,$4}' log.txt
---------------------------------------------
Are like
a
There orange,apple,mongo
$ awk '!/th/ {print $2,$4}' log.txt
---------------------------------------------
Are like
a
There orange,apple,mongo
awk脚本
关于 awk 脚本，我们需要注意两个关键词 BEGIN 和 END。

    BEGIN{ 这里面放的是执行前的语句 } 
    END {这里面放的是处理完所有的行后要执行的语句 } 
    {这里面放的是处理每一行时要执行的语句} 

假设有这么一个文件（学生成绩表）： 
$ cat score.txt
Marry   2143 78 84 77
Jack    2321 66 78 45
Tom     2122 48 77 71
Mike    2537 87 97 95
Bob     2415 40 57 62
我们的 awk 脚本如下：
$ cat cal.awk
#!/bin/awk -f
#运行前
BEGIN {
    math = 0
    english = 0
    computer = 0
    printf "NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n"
    printf "---------------------------------------------\n"
}
#运行中
{
    math+=$3
    english+=$4
    computer+=$5
    printf "%-6s %-6s %4d %8d %8d %8d\n", $1, $2, $3,$4,$5, $3+$4+$5
}
#运行后
END {
    printf "---------------------------------------------\n"
    printf "  TOTAL:%10d %8d %8d \n", math, english, computer
    printf "AVERAGE:%10.2f %8.2f %8.2f\n", math/NR, english/NR, computer/NR
}
我们来看一下执行结果：
$ awk -f cal.awk score.txt
NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL
---------------------------------------------
Marry  2143     78       84       77      239
Jack   2321     66       78       45      189
Tom    2122     48       77       71      196
Mike   2537     87       97       95      279
Bob    2415     40       57       62      159
---------------------------------------------
  TOTAL:       319      393      350
AVERAGE:     63.80    78.60    70.00
另外一些实例
AWK 的 hello world 程序为：
BEGIN { print "Hello, world!" }
计算文件大小
$ ls -l *.txt | awk '{sum+=$5} END {print sum}'
从文件中找出长度大于 80 的行： 
awk 'length>80' log.txt
打印九九乘法表 
seq 9 | sed 'H;g' | awk -v RS='' '{for(i=1;i<=NF;i++)printf("%dx%d=%d%s", i, NR, i*NR, i==NR?"\n":"\t")}'
注意：：：
AWK被excel等软件替代了，但是具有编程的功能，脚本中可以使用。
cmp字节比较文件
patch给文件打补丁，补丁文件由diff生成
pr打印文件，装上打印机后可以使用
-------------------------------chacpter8：学习shell 变成 shell script----------------------------------
 1.shell scrip是 纯文本文件，可以使用任何编辑器编写，也是一种编写语言，不同shell环境下耦合度不同步。命令执行从左向右执行，使用\进行续行，#代表注释。bash和sh来执行shell.sh
#/bin/bash代表使用bash来执行，python写的脚本也会有执行的shell
注释写明内容和信息、版本信息、作者与联络方式等等
环境变量的设定echo -e代表后面的内容转义输出
加上可执行权限x即可以进行脚本的运行
2.菜鸟教程相关内容
Shell 教程
Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。
Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。
Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。
Shell 在线工具
Shell 脚本
Shell 脚本（shell script），是一种为 shell 编写的脚本程序。 
业界所说的 shell 通常都是指 shell 脚本，但读者朋友要知道，shell 和 shell script 是两个不同的概念。
由于习惯的原因，简洁起见，本文出现的 "shell编程" 都是指 shell 脚本编程，不是指开发 shell 自身。
Shell 环境
Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。
Linux 的 Shell 种类众多，常见的有：

    Bourne Shell（/usr/bin/sh或/bin/sh）
    Bourne Again Shell（/bin/bash）
    C Shell（/usr/bin/csh）
    K Shell（/usr/bin/ksh）
    Shell for Root（/sbin/sh）
    …… 

本教程关注的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。
在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 #!/bin/sh，它同样也可以改为 #!/bin/bash。
#! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。
第一个shell脚本
打开文本编辑器(可以使用 vi/vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了。 
输入一些代码，第一行一般是这样： 
实例
#!/bin/bash
echo "Hello World !"

运行实例 » 
#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。
echo 命令用于向窗口输出文本。 
运行 Shell 脚本有两种方法：
1、作为可执行程序
将上面的代码保存为 test.sh，并 cd 到相应目录：
chmod +x ./test.sh  #使脚本具有执行权限
./test.sh  #执行脚本
注意，一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。 
2、作为解释器参数
这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如： 
/bin/sh test.sh
/bin/php test.php
这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。
Shell 变量
定义变量时，变量名不加美元符号（$，PHP语言中变量需要），如：
your_name="runoob.com"
注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则： 

    命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 
    中间不能有空格，可以使用下划线 _。 
    不能使用标点符号。 
    不能使用bash里的关键字（可用help命令查看保留关键字）。 

有效的 Shell 变量名示例如下：
RUNOOB
LD_LIBRARY_PATH
_var
var2
无效的变量命名：
?var=123
user*name=runoob
除了显式地直接赋值，还可以用语句给变量赋值，如：
for file in `ls /etc`
或
for file in $(ls /etc)
以上语句将 /etc 下目录的文件名循环出来。
使用变量
使用一个定义过的变量，只要在变量名前面加美元符号即可，如：
实例
your_name="qinjx"
echo $your_name
echo ${your_name}
变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况： 
实例
for skill in Ada Coffe Action Java; do
 echo "I am good at ${skill}Script"
done
如果不给skill变量加花括号，写成echo "I am good at $skillScript"，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。 
推荐给所有变量加上花括号，这是个好的编程习惯。 
已定义的变量，可以被重新定义，如：
实例
your_name="tom"
echo $your_name
your_name="alibaba"
echo $your_name
这样写是合法的，但注意，第二次赋值的时候不能写$your_name="alibaba"，使用变量的时候才加美元符（$）。 
只读变量
使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。
下面的例子尝试更改只读变量，结果报错：
实例
#!/bin/bash

myUrl="https://www.google.com"
readonly myUrl
myUrl="https://www.runoob.com"
运行脚本，结果如下：
/bin/sh: NAME: This variable is read only.
删除变量
使用 unset 命令可以删除变量。语法：
unset variable_name
变量被删除后不能再次使用。unset 命令不能删除只读变量。
实例
实例
#!/bin/sh

myUrl="https://www.runoob.com"
unset myUrl
echo $myUrl
以上实例执行将没有任何输出。
变量类型
运行shell时，会同时存在三种变量：

    1) 局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。
    2) 环境变量 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。
    3) shell变量 shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行

Shell 字符串
字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。 
单引号 
str='this is a string'
单引号字符串的限制： 

    单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 
    单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。 

双引号 
实例
your_name="runoob"
str="Hello, I know you are \"$your_name\"! \n"
echo -e $str
输出结果为：
Hello, I know you are "runoob"! 
双引号的优点：

    双引号里可以有变量 
    双引号里可以出现转义字符 

拼接字符串 
实例
your_name="runoob"
# 使用双引号拼接
greeting="hello, "$your_name" !"
greeting_1="hello, ${your_name} !"
echo $greeting $greeting_1

# 使用单引号拼接
greeting_2='hello, '$your_name' !'
greeting_3='hello, ${your_name} !'
echo $greeting_2 $greeting_3
输出结果为：
hello, runoob ! hello, runoob !
hello, runoob ! hello, ${your_name} !
获取字符串长度 
实例
string="abcd"
echo ${#string} # 输出 4
变量为数组时，${#string} 等价于 ${#string[0]}:
实例
string="abcd"
echo ${#string[0]} # 输出 4
提取子字符串 
以下实例从字符串第 2 个字符开始截取 4 个字符：
实例
string="runoob is a great site"
echo ${string:1:4} # 输出 unoo
注意：第一个字符的索引值为 0。
查找子字符串 
查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：
实例
string="runoob is a great site"
echo `expr index "$string" io` # 输出 4
注意： 以上脚本中 ` 是反引号，而不是单引号 '，不要看错了哦。
Shell 数组
bash支持一维数组（不支持多维数组），并且没有限定数组的大小。
类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。 
定义数组 
在 Shell 中，用括号来表示数组，数组元素用"空格"符号分割开。定义数组的一般形式为： 
数组名=(值1 值2 ... 值n)
例如：
array_name=(value0 value1 value2 value3)
或者 
array_name=(
value0
value1
value2
value3
)
还可以单独定义数组的各个分量： 
array_name[0]=value0
array_name[1]=value1
array_name[n]=valuen
可以不使用连续的下标，而且下标的范围没有限制。 
读取数组 
读取数组元素值的一般格式是：
${数组名[下标]}
例如：
valuen=${array_name[n]}
使用 @ 符号可以获取数组中的所有元素，例如： 
echo ${array_name[@]}
获取数组的长度 
获取数组长度的方法与获取字符串长度的方法相同，例如： 
实例
# 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
# 取得数组单个元素的长度
lengthn=${#array_name[n]}
Shell 注释
以 # 开头的行就是注释，会被解释器忽略。
通过每一行加一个 # 号设置多行注释，像这样： 
实例
#--------------------------------------------
# 这是一个注释
# author：菜鸟教程
# site：www.runoob.com
# slogan：学的不仅是技术，更是梦想！
#--------------------------------------------
##### 用户配置区 开始 #####
#
#
# 这里可以添加脚本描述信息
# 
#
##### 用户配置区 结束  #####
如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？
每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。 
多行注释 
多行注释还可以使用以下格式：
:<<EOF
注释内容...
注释内容...
注释内容...
EOF
EOF 也可以使用其他符号:
实例
:<<'
注释内容...
注释内容...
注释内容...
'

:<<!
注释内容...
注释内容...
注释内容...
!
Shell 传递参数
我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……
实例
以下实例我们向脚本传递三个参数，并分别输出，其中 $0 为执行的文件名（包含文件路径）：
实例
#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

echo "Shell 传递参数实例！";
echo "执行的文件名：$0";
echo "第一个参数为：$1";
echo "第二个参数为：$2";
echo "第三个参数为：$3";
为脚本设置可执行权限，并执行脚本，输出结果如下所示：
$ chmod +x test.sh 
$ ./test.sh 1 2 3
Shell 传递参数实例！
执行的文件名：./test.sh
第一个参数为：1
第二个参数为：2
第三个参数为：3
另外，还有几个特殊字符用来处理参数：
参数处理
	
说明
$#
	
传递到脚本的参数个数
$*
	
以一个单字符串显示所有向脚本传递的参数。如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。
$$
	
脚本运行的当前进程ID号
$!
	
后台运行的最后一个进程的ID号
$@
	
与$*相同，但是使用时加引号，并在引号中返回每个参数。如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。
$-
	
显示Shell使用的当前选项，与set命令功能相同。
$?
	
显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。
实例
#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

echo "Shell 传递参数实例！";
echo "第一个参数为：$1";

echo "参数个数为：$#";
echo "传递的参数作为一个字符串显示：$*";
执行脚本，输出结果如下所示：
$ chmod +x test.sh 
$ ./test.sh 1 2 3
Shell 传递参数实例！
第一个参数为：1
参数个数为：3
传递的参数作为一个字符串显示：1 2 3
$* 与 $@ 区别：

    相同点：都是引用所有参数。
    不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " * " 等价于 "1 2 3"（传递了一个参数），而 "@" 等价于 "1" "2" "3"（传递了三个参数）。 

实例
#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

echo "-- \$* 演示 ---"
for i in "$*"; do
 echo $i
done

echo "-- \$@ 演示 ---"
for i in "$@"; do
 echo $i
done
执行脚本，输出结果如下所示：
$ chmod +x test.sh 
$ ./test.sh 1 2 3
-- $* 演示 ---
1 2 3
-- $@ 演示 ---
1
2
3
Shell 数组
数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。 
与大部分编程语言类似，数组元素的下标由 0 开始。
Shell 数组用括号来表示，元素用"空格"符号分割开，语法格式如下：
array_name=(value1 value2 ... valuen)
实例
#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com
my_array=(A B "C" D)
我们也可以使用下标来定义数组:
array_name[0]=value0
array_name[1]=value1
array_name[2]=value2
读取数组
读取数组元素值的一般格式是：
${array_name[index]}
实例
#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com
my_array=(A B "C" D)
echo "第一个元素为: ${my_array[0]}"
echo "第二个元素为: ${my_array[1]}"
echo "第三个元素为: ${my_array[2]}"
echo "第四个元素为: ${my_array[3]}"
执行脚本，输出结果如下所示：
$ chmod +x test.sh 
$ ./test.sh
第一个元素为: A
第二个元素为: B
第三个元素为: C
第四个元素为: D
获取数组中的所有元素
使用@ 或 * 可以获取数组中的所有元素，例如：
#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com
my_array[0]=A
my_array[1]=B
my_array[2]=C
my_array[3]=D
echo "数组的元素为: ${my_array[*]}"
echo "数组的元素为: ${my_array[@]}"
执行脚本，输出结果如下所示：
$ chmod +x test.sh 
$ ./test.sh
数组的元素为: A B C D
数组的元素为: A B C D
获取数组的长度
获取数组长度的方法与获取字符串长度的方法相同，例如：
#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com
my_array[0]=A
my_array[1]=B
my_array[2]=C
my_array[3]=D
echo "数组元素个数为: ${#my_array[*]}"
echo "数组元素个数为: ${#my_array[@]}"
执行脚本，输出结果如下所示：
$ chmod +x test.sh 
$ ./test.sh
数组元素个数为: 4
数组元素个数为: 4
Shell 基本运算符
Shell 和其他编程语言一样，支持多种运算符，包括：

    算数运算符
    关系运算符
    布尔运算符
    字符串运算符
    文件测试运算符

原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。 
expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 
例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ')：
实例
#!/bin/bash

val=`expr 2 + 2`
echo "两数之和为 : $val"

运行实例 » 
执行脚本，输出结果如下所示：
两数之和为 : 4
两点注意：

    表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。 
    完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。 

算术运算符
下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：
运算符
	
说明
	
举例
+
	
加法
	
`expr $a + $b` 结果为 30。
-
	
减法
	
`expr $a - $b` 结果为 -10。
*
	
乘法
	
`expr $a \* $b` 结果为  200。
/
	
除法
	
`expr $b / $a` 结果为 2。
%
	
取余
	
`expr $b % $a` 结果为 0。
=
	
赋值
	
a=$b 把变量 b 的值赋给 a。
==
	
相等。用于比较两个数字，相同则返回 true。
	
[ $a == $b ] 返回 false。
!=
	
不相等。用于比较两个数字，不相同则返回 true。
	
[ $a != $b ] 返回 true。
注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。
实例
算术运算符实例如下：
实例
#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

a=10
b=20

val=`expr $a + $b`
echo "a + b : $val"

val=`expr $a - $b`
echo "a - b : $val"

val=`expr $a \* $b`
echo "a * b : $val"

val=`expr $b / $a`
echo "b / a : $val"

val=`expr $b % $a`
echo "b % a : $val"

if [ $a == $b ]
then
 echo "a 等于 b"
fi
if [ $a != $b ]
then
 echo "a 不等于 b"
fi
执行脚本，输出结果如下所示：
a + b : 30
a - b : -10
a * b : 200
b / a : 2
b % a : 0
a 不等于 b
注意：

    乘号(*)前边必须加反斜杠(\)才能实现乘法运算； 
    if...then...fi 是条件语句，后续将会讲解。 
    在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 "*" 不需要转义符号 "\" 。 

关系运算符
关系运算符只支持数字，不支持字符串，除非字符串的值是数字。
下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：
运算符
	
说明
	
举例
-eq
	
检测两个数是否相等，相等返回 true。
	
[ $a -eq $b ] 返回 false。
-ne
	
检测两个数是否不相等，不相等返回 true。
	
[ $a -ne $b ] 返回 true。
-gt
	
检测左边的数是否大于右边的，如果是，则返回 true。
	
[ $a -gt $b ] 返回 false。
-lt
	
检测左边的数是否小于右边的，如果是，则返回 true。
	
[ $a -lt $b ] 返回 true。
-ge
	
检测左边的数是否大于等于右边的，如果是，则返回 true。
	
[ $a -ge $b ] 返回 false。
-le
	
检测左边的数是否小于等于右边的，如果是，则返回 true。
	
[ $a -le $b ] 返回 true。
实例
关系运算符实例如下：
实例
#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

a=10
b=20

if [ $a -eq $b ]
then
 echo "$a -eq $b : a 等于 b"
else
 echo "$a -eq $b: a 不等于 b"
fi
if [ $a -ne $b ]
then
 echo "$a -ne $b: a 不等于 b"
else
 echo "$a -ne $b : a 等于 b"
fi
if [ $a -gt $b ]
then
 echo "$a -gt $b: a 大于 b"
else
 echo "$a -gt $b: a 不大于 b"
fi
if [ $a -lt $b ]
then
 echo "$a -lt $b: a 小于 b"
else
 echo "$a -lt $b: a 不小于 b"
fi
if [ $a -ge $b ]
then
 echo "$a -ge $b: a 大于或等于 b"
else
 echo "$a -ge $b: a 小于 b"
fi
if [ $a -le $b ]
then
 echo "$a -le $b: a 小于或等于 b"
else
 echo "$a -le $b: a 大于 b"
fi
执行脚本，输出结果如下所示：
10 -eq 20: a 不等于 b
10 -ne 20: a 不等于 b
10 -gt 20: a 不大于 b
10 -lt 20: a 小于 b
10 -ge 20: a 小于 b
10 -le 20: a 小于或等于 b
布尔运算符
下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：
运算符
	
说明
	
举例
!
	
非运算，表达式为 true 则返回 false，否则返回 true。
	
[ ! false ] 返回 true。
-o
	
或运算，有一个表达式为 true 则返回 true。
	
[ $a -lt 20 -o $b -gt 100 ] 返回 true。
-a
	
与运算，两个表达式都为 true 才返回 true。
	
[ $a -lt 20 -a $b -gt 100 ] 返回 false。
实例
布尔运算符实例如下：
实例
#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

a=10
b=20

if [ $a != $b ]
then
 echo "$a != $b : a 不等于 b"
else
 echo "$a == $b: a 等于 b"
fi
if [ $a -lt 100 -a $b -gt 15 ]
then
 echo "$a 小于 100 且 $b 大于 15 : 返回 true"
else
 echo "$a 小于 100 且 $b 大于 15 : 返回 false"
fi
if [ $a -lt 100 -o $b -gt 100 ]
then
 echo "$a 小于 100 或 $b 大于 100 : 返回 true"
else
 echo "$a 小于 100 或 $b 大于 100 : 返回 false"
fi
if [ $a -lt 5 -o $b -gt 100 ]
then
 echo "$a 小于 5 或 $b 大于 100 : 返回 true"
else
 echo "$a 小于 5 或 $b 大于 100 : 返回 false"
fi
执行脚本，输出结果如下所示：
10 != 20 : a 不等于 b
10 小于 100 且 20 大于 15 : 返回 true
10 小于 100 或 20 大于 100 : 返回 true
10 小于 5 或 20 大于 100 : 返回 false
逻辑运算符
以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:
运算符
	
说明
	
举例
&&
	
逻辑的 AND
	
[[ $a -lt 100 && $b -gt 100 ]] 返回 false
||
	
逻辑的 OR
	
[[ $a -lt 100 || $b -gt 100 ]] 返回 true
实例
逻辑运算符实例如下：
实例
#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

a=10
b=20

if [[ $a -lt 100 && $b -gt 100 ]]
then
 echo "返回 true"
else
 echo "返回 false"
fi

if [[ $a -lt 100 || $b -gt 100 ]]
then
 echo "返回 true"
else
 echo "返回 false"
fi
执行脚本，输出结果如下所示：
返回 false
返回 true
字符串运算符
下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：
运算符
	
说明
	
举例
=
	
检测两个字符串是否相等，相等返回 true。
	
[ $a = $b ] 返回 false。
!=
	
检测两个字符串是否不相等，不相等返回 true。
	
[ $a != $b ] 返回 true。
-z
	
检测字符串长度是否为0，为0返回 true。
	
[ -z $a ] 返回 false。
-n
	
检测字符串长度是否不为 0，不为 0 返回 true。
	
[ -n "$a" ] 返回 true。
$
	
检测字符串是否为空，不为空返回 true。
	
[ $a ] 返回 true。
实例
字符串运算符实例如下：
实例

#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

a="abc"
b="efg"

if [ $a = $b ]
then
 echo "$a = $b : a 等于 b"
else
 echo "$a = $b: a 不等于 b"
fi
if [ $a != $b ]
then
 echo "$a != $b : a 不等于 b"
else
 echo "$a != $b: a 等于 b"
fi
if [ -z $a ]
then
 echo "-z $a : 字符串长度为 0"
else
 echo "-z $a : 字符串长度不为 0"
fi
if [ -n "$a" ]
then
 echo "-n $a : 字符串长度不为 0"
else
 echo "-n $a : 字符串长度为 0"
fi
if [ $a ]
then
 echo "$a : 字符串不为空"
else
 echo "$a : 字符串为空"
fi
执行脚本，输出结果如下所示：
abc = efg: a 不等于 b
abc != efg : a 不等于 b
-z abc : 字符串长度不为 0
-n abc : 字符串长度不为 0
abc : 字符串不为空
文件测试运算符
文件测试运算符用于检测 Unix 文件的各种属性。 
属性检测描述如下：
操作符
	
说明
	
举例
-b file
	
检测文件是否是块设备文件，如果是，则返回 true。
	
[ -b $file ] 返回 false。
-c file
	
检测文件是否是字符设备文件，如果是，则返回 true。
	
[ -c $file ] 返回 false。
-d file
	
检测文件是否是目录，如果是，则返回 true。
	
[ -d $file ] 返回 false。
-f file
	
检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。
	
[ -f $file ] 返回 true。
-g file
	
检测文件是否设置了 SGID 位，如果是，则返回 true。
	
[ -g $file ] 返回 false。
-k file
	
检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。
	
[ -k $file ] 返回 false。
-p file
	
检测文件是否是有名管道，如果是，则返回 true。
	
[ -p $file ] 返回 false。
-u file
	
检测文件是否设置了 SUID 位，如果是，则返回 true。
	
[ -u $file ] 返回 false。
-r file
	
检测文件是否可读，如果是，则返回 true。
	
[ -r $file ] 返回 true。
-w file
	
检测文件是否可写，如果是，则返回 true。
	
[ -w $file ] 返回 true。
-x file
	
检测文件是否可执行，如果是，则返回 true。
	
[ -x $file ] 返回 true。
-s file
	
检测文件是否为空（文件大小是否大于0），不为空返回 true。
	
[ -s $file ] 返回 true。
-e file
	
检测文件（包括目录）是否存在，如果是，则返回 true。
	
[ -e $file ] 返回 true。
其他检查符：

    -S: 判断某文件是否 socket。 
    -L: 检测文件是否存在并且是一个符号链接。 

实例
变量 file 表示文件 /var/www/runoob/test.sh，它的大小为 100 字节，具有 rwx 权限。下面的代码，将检测该文件的各种属性：
实例
#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

file="/var/www/runoob/test.sh"
if [ -r $file ]
then
 echo "文件可读"
else
 echo "文件不可读"
fi
if [ -w $file ]
then
 echo "文件可写"
else
 echo "文件不可写"
fi
if [ -x $file ]
then
 echo "文件可执行"
else
 echo "文件不可执行"
fi
if [ -f $file ]
then
 echo "文件为普通文件"
else
 echo "文件为特殊文件"
fi
if [ -d $file ]
then
 echo "文件是个目录"
else
 echo "文件不是个目录"
fi
if [ -s $file ]
then
 echo "文件不为空"
else
 echo "文件为空"
fi
if [ -e $file ]
then
 echo "文件存在"
else
 echo "文件不存在"
fi
执行脚本，输出结果如下所示：
文件可读
文件可写
文件可执行
文件为普通文件
文件不是个目录
文件不为空
文件存在
Shell echo命令
Shell 的 echo 指令与 PHP 的 echo 指令类似，都是用于字符串的输出。命令格式：
echo string
您可以使用echo实现更复杂的输出格式控制。 
1.显示普通字符串:
echo "It is a test"
这里的双引号完全可以省略，以下命令与上面实例效果一致：
echo It is a test
2.显示转义字符
echo "\"It is a test\""
结果将是:
"It is a test"
同样，双引号也可以省略
3.显示变量
read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量
#!/bin/sh
read name 
echo "$name It is a test"
以上代码保存为 test.sh，name 接收标准输入的变量，结果将是: 
[root@www ~]# sh test.sh
OK                     #标准输入
OK It is a test        #输出
4.显示换行
echo -e "OK! \n" # -e 开启转义
echo "It is a test"
输出结果：
OK!
It is a test
5.显示不换行 
#!/bin/sh
echo -e "OK! \c" # -e 开启转义 \c 不换行
echo "It is a test"
输出结果：
OK! It is a test
6.显示结果定向至文件
echo "It is a test" > myfile
7.原样输出字符串，不进行转义或取变量(用单引号)
echo '$name\"'
输出结果：
$name\"
8.显示命令执行结果
echo `date`
注意： 这里使用的是反引号 `, 而不是单引号 '。
结果将显示当前日期
Thu Jul 24 10:08:46 CST 2014
Shell 流程控制 
和 Java、PHP 等语言不一样，sh 的流程控制不可为空，如(以下为 PHP 流程控制写法)： 
实例
<?php
if (isset($_GET["q"])) {
    search(q);
}
else {
 // 不做任何事情
}
在 sh/bash 里可不能这么写，如果 else 分支没有语句执行，就不要写这个 else。 
if else 
fi
if 语句语法格式：
if condition
then
    command1 
    command2
    ...
    commandN 
fi
写成一行（适用于终端命令提示符）： 
if [ $(ps -ef | grep -c "ssh") -gt 1 ]; then echo "true"; fi
末尾的 fi 就是 if 倒过来拼写，后面还会遇到类似的。 
if else 
if else 语法格式：
if condition
then
    command1 
    command2
    ...
    commandN
else
    command
fi
if else-if else 
if else-if else 语法格式：
if condition1
then
    command1
elif condition2 
then 
    command2
else
    commandN
fi
以下实例判断两个变量是否相等：
实例
a=10
b=20
if [ $a == $b ]
then
 echo "a 等于 b"
elif [ $a -gt $b ]
then
 echo "a 大于 b"
elif [ $a -lt $b ]
then
 echo "a 小于 b"
else
 echo "没有符合的条件"
fi
输出结果：
a 小于 b
if else 语句经常与 test 命令结合使用，如下所示：
实例
num1=$[2*3]
num2=$[1+5]
if test $[num1] -eq $[num2]
then
 echo '两个数字相等!'
else
 echo '两个数字不相等!'
fi
输出结果：
两个数字相等!
for 循环 
与其他编程语言类似，Shell支持for循环。 
for循环一般格式为： 
for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done
写成一行： 
for var in item1 item2 ... itemN; do command1; command2… done;
当变量值在列表里，for 循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的 shell 命令和语句。in 列表可以包含替换、字符串和文件名。 
in列表是可选的，如果不用它，for循环使用命令行的位置参数。 
例如，顺序输出当前列表中的数字：
实例
for loop in 1 2 3 4 5
do
 echo "The value is: $loop"
done
输出结果： 
The value is: 1
The value is: 2
The value is: 3
The value is: 4
The value is: 5
顺序输出字符串中的字符：
#!/bin/bash
for str in This is a string
do
    echo $str
done
输出结果：
This
is
a
string
while 语句
while 循环用于不断执行一系列命令，也用于从输入文件中读取数据。其语法格式为：
while condition
do
    command
done
以下是一个基本的 while 循环，测试条件是：如果 int 小于等于 5，那么条件返回真。int 从 1 开始，每次循环处理时，int 加 1。运行上述脚本，返回数字 1 到 5，然后终止。 
实例
#!/bin/bash
int=1
while(( $int<=5 ))
do
 echo $int
 let "int++"
done
运行脚本，输出： 
1
2
3
4
5
以上实例使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量，具体可查阅：Bash let 命令
。 
while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按<Ctrl-D>结束循环。 
实例
echo '按下 <CTRL-D> 退出'
echo -n '输入你最喜欢的网站名: '
while read FILM
do
 echo "是的！$FILM 是一个好网站"
done
运行脚本，输出类似下面： 
按下 <CTRL-D> 退出
输入你最喜欢的网站名:菜鸟教程
是的！菜鸟教程 是一个好网站
无限循环 
无限循环语法格式：
while :
do
    command
done
或者 
while true
do
    command
done
或者 
for (( ; ; ))
until 循环
until 循环执行一系列命令直至条件为 true 时停止。 
until 循环与 while 循环在处理方式上刚好相反。
一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。 
until 语法格式:
until condition
do
    command
done
condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。
以下实例我们使用 until 命令来输出 0 ~ 9 的数字：
实例
#!/bin/bash

a=0

until [ ! $a -lt 10 ]
do
 echo $a
 a=`expr $a + 1`
done
运行结果：
输出结果为：
0
1
2
3
4
5
6
7
8
9
case ... esac
case ... esac 为多选择语句，与其他语言中的 switch ... case 语句类似，是一种多分支选择结构，每个 case 分支用右圆括号开始，用两个分号 ;; 表示 break，即执行结束，跳出整个 case ... esac 语句，esac（就是 case 反过来）作为结束标记。
可以用 case 语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。
case ... esac 语法格式如下：
case 值 in
模式1)
    command1
    command2
    ...
    commandN
    ;;
模式2)
    command1
    command2
    ...
    commandN
    ;;
esac
case 工作方式如上所示，取值后面必须为单词 in，每一模式必须以右括号结束。取值可以为变量或常数，匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。 
取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。 
下面的脚本提示输入 1 到 4，与每一种模式进行匹配： 
实例
echo '输入 1 到 4 之间的数字:'
echo '你输入的数字为:'
read aNum
case $aNum in
    1) echo '你选择了 1'
 ;;
    2) echo '你选择了 2'
 ;;
    3) echo '你选择了 3'
 ;;
    4) echo '你选择了 4'
 ;;
 *) echo '你没有输入 1 到 4 之间的数字'
 ;;
esac
输入不同的内容，会有不同的结果，例如： 
输入 1 到 4 之间的数字:
你输入的数字为:
3
你选择了 3
下面的脚本匹配字符串： 
实例
#!/bin/sh

site="runoob"

case "$site" in
 "runoob") echo "菜鸟教程" 
 ;;
 "google") echo "Google 搜索" 
 ;;
 "taobao") echo "淘宝网" 
 ;;
esac
输出结果为：
菜鸟教程
跳出循环
在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。 
break命令 
break命令允许跳出所有循环（终止执行后面的所有循环）。 
下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用break命令。 
实例
#!/bin/bash
while :
do
 echo -n "输入 1 到 5 之间的数字:"
 read aNum
 case $aNum in
        1|2|3|4|5) echo "你输入的数字为 $aNum!"
 ;;
 *) echo "你输入的数字不是 1 到 5 之间的! 游戏结束"
 break
 ;;
 esac
done
执行以上代码，输出结果为：
输入 1 到 5 之间的数字:3
你输入的数字为 3!
输入 1 到 5 之间的数字:7
你输入的数字不是 1 到 5 之间的! 游戏结束
continue 
continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。 
对上面的例子进行修改： 
实例
#!/bin/bash
while :
do
 echo -n "输入 1 到 5 之间的数字: "
 read aNum
 case $aNum in
        1|2|3|4|5) echo "你输入的数字为 $aNum!"
 ;;
 *) echo "你输入的数字不是 1 到 5 之间的!"
 continue
 echo "游戏结束"
 ;;
 esac
done
运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 echo "游戏结束" 永远不会被执行。 
Shell 函数
linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。
shell中函数的定义格式如下： 
[ function ] funname [()]

{

    action;

 [return int;]

}
说明：

    1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。 
    2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255 

下面的例子定义了一个函数并进行调用： 
实例
#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

demoFun(){
 echo "这是我的第一个 shell 函数!"
}
echo "-----函数开始执行-----"
demoFun
echo "-----函数执行完毕-----"
输出结果： 
-----函数开始执行-----
这是我的第一个 shell 函数!
-----函数执行完毕-----
下面定义一个带有return语句的函数： 
实例
#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

funWithReturn(){
 echo "这个函数会对输入的两个数字进行相加运算..."
 echo "输入第一个数字: "
 read aNum
 echo "输入第二个数字: "
 read anotherNum
 echo "两个数字分别为 $aNum 和 $anotherNum !"
 return $(($aNum+$anotherNum))
}
funWithReturn
echo "输入的两个数字之和为 $? !"
输出类似下面： 
这个函数会对输入的两个数字进行相加运算...
输入第一个数字: 
1
输入第二个数字: 
2
两个数字分别为 1 和 2 !
输入的两个数字之和为 3 !
函数返回值在调用该函数后通过 $? 来获得。 
注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。 
函数参数
在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数... 
带参数的函数示例： 
实例
#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

funWithParam(){
 echo "第一个参数为 $1 !"
 echo "第二个参数为 $2 !"
 echo "第十个参数为 $10 !"
 echo "第十个参数为 ${10} !"
 echo "第十一个参数为 ${11} !"
 echo "参数总数有 $# 个!"
 echo "作为一个字符串输出所有参数 $* !"
}
funWithParam 1 2 3 4 5 6 7 8 9 34 73
输出结果： 
第一个参数为 1 !
第二个参数为 2 !
第十个参数为 10 !
第十个参数为 34 !
第十一个参数为 73 !
参数总数有 11 个!
作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !
注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n>=10时，需要使用${n}来获取参数。 
另外，还有几个特殊字符用来处理参数： 
参数处理
	
说明
$#
	
传递到脚本或函数的参数个数
$*
	
以一个单字符串显示所有向脚本传递的参数
$$
	
脚本运行的当前进程ID号
$!
	
后台运行的最后一个进程的ID号
$@
	
与$*相同，但是使用时加引号，并在引号中返回每个参数。
$-
	
显示Shell使用的当前选项，与set命令功能相同。
$?
	
显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。
Shell test 命令
Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。
数值测试
参数
	
说明
-eq
	
等于则为真
-ne
	
不等于则为真
-gt
	
大于则为真
-ge
	
大于等于则为真
-lt
	
小于则为真
-le
	
小于等于则为真
实例
num1=100
num2=100
if test $[num1] -eq $[num2]
then
 echo '两个数相等！'
else
 echo '两个数不相等！'
fi
输出结果：
两个数相等！
代码中的 [] 执行基本的算数运算，如：
实例
#!/bin/bash

a=5
b=6

result=$[a+b] # 注意等号两边不能有空格
echo "result 为： $result"
结果为:
result 为： 11
字符串测试
参数
	
说明
=
	
等于则为真
!=
	
不相等则为真
-z 字符串
	
字符串的长度为零则为真
-n 字符串
	
字符串的长度不为零则为真
实例
num1="ru1noob"
num2="runoob"
if test $num1 = $num2
then
 echo '两个字符串相等!'
else
 echo '两个字符串不相等!'
fi
输出结果：
两个字符串不相等!
文件测试
参数
	
说明
-e 文件名
	
如果文件存在则为真
-r 文件名
	
如果文件存在且可读则为真
-w 文件名
	
如果文件存在且可写则为真
-x 文件名
	
如果文件存在且可执行则为真
-s 文件名
	
如果文件存在且至少有一个字符则为真
-d 文件名
	
如果文件存在且为目录则为真
-f 文件名
	
如果文件存在且为普通文件则为真
-c 文件名
	
如果文件存在且为字符型特殊文件则为真
-b 文件名
	
如果文件存在且为块特殊文件则为真
实例
cd /bin
if test -e ./bash
then
 echo '文件已存在!'
else
 echo '文件不存在!'
fi
输出结果：
文件已存在!
另外，Shell 还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为： ! 最高， -a 次之， -o 最低。例如：
实例
cd /bin
if test -e ./notFile -o -e ./bash
then
 echo '至少有一个文件存在!'
else
 echo '两个文件都不存在'
fi
输出结果：
至少有一个文件存在!
注意：：：
条件 && a||b--条件满足执行a，不满足执行b 
-------------------------------chacpter9:markdown及其处理----------------------------------
latex排版比较复杂—需要写代码
markdown开销很小
1.语法内容查看菜鸟教程
2.使用pandoc命令把md文件批量转化为pdf文件—具体内容查看上传的代码
补充命令1：
dialog命令 man dialog查看更详细的说明—桌面显示
Liunx下的dialog是一个可以创建对话框的工具，每个对话框提供的输出有两种形式：1、将所有输出到stderr，不显示到屏幕；2、使用退出状态码，OK为0，NO为1，ESC为255。
通用选项（common options）
这个选项用来设置dialog box的背景、颜色和标题等。
--title <title>：指定将在对话框的上方显示的标题字符串。
--colors：解读嵌入式\ Z的对话框中的特殊文本序列，序列由下面的字符0-7, b，B, u, U等组成，恢复正常的设置使用\Zn。
--no-shadow：禁止阴影出现在每个对话框的底部。
--shadow：出现阴影效果。
--insecure：输入部件的密码时，使用星号来代表每个字符。
--no-cancel：设置在输入框、菜单和复选框中不显示cancel项。
--clear：完成清屏操作，在框体显示结束后，清除框体，这个参数只能单独使用，不能和别的参数联合使用。
--ok-label <str>：覆盖使用OK按钮标签，换做其它字符。
--cancel-label <str>：功能同上。
--backtitle <backtitle>：指定的backtitle字符串显示在背景顶端。
--begin <y> <x>：指定对话框左上角在屏幕上的坐标。
--timeout <secs>：超时（返回的错误代码），如果用户在指定的时间内没有给出相应动作，就按超时处理。
--defaultno：使的是默认值yes/no，使用no。
--sleep <secs>
--stderr：以标准错误方式输出。
--stdout：以标准方式输出。
--default-item <str>：设置在一份清单、表格或菜单中的默认项目，通常在框中的第一项是默认的。
窗体类型：
常见的对话框控件选项如下所示：
--calendar：提供了一个日历，让你可以选择日期。
--checklist：允许你显示一个选项列表，每个选项都可以被单独的选择(复选框)。
--from：允许建立一个带标签的文本字段，并要求填写。
--fselect：提供一个路径，让你选择浏览的文件。
--gauge：显示一个表，呈现出完成的百分比，就是显示出进度。
--infobox：显示消息后，（没有等待响应）对话框立刻返回，但不清除屏幕(信息框)。
--inputbox：让用户输入文本(输入框)。
--inputmenu：提供一个可供用户编辑的菜单（可编辑的菜单框）。
--menu：显示一个列表供用户选择(菜单框)。
--msgbox：显示一条消息，并要求用户选择一个确定按钮(消息框)。
--pause：显示一个表格用来显示一个指定的暂停期的状态。
--passwordbox：显示一个输入框，它隐藏文本。
--passwordfrom：显示一个来源于标签并且隐藏的文本字段。
--radiolist：提供一个菜单项目组，只有一个项目，可以选择(单选框)。
--tailbox：在一个滚动窗口文件中使用tail命令来显示文本。
--tailboxbg：跟tailbox类似，但是在background模式下操作。
--textbox：在带有滚动条的文本框中显示文件的内容(文本框)。
--timebox：提供一个窗口，选择小时、分钟、秒。
--yesno：提供一个带有yes和no按钮的简单信息框(是/否框)。
命令示例
消息框
格式：
dialog --msgbox text height width
例子：
$ dialog --title TESTING --msgbox "this is a test" 10 20
yesno框
格式：
dialog --yesno text height width
例子：
$ dialog --title "yes/no" --no-shadow --yesno "Delete the file /tmp/canjian.txt?" 10 30
输入框
格式：
dialog --inputbox text height width
例子：
$ dialog --title "Input your name" --inputbox "Please input your name:" 10 30  2> /tmp/name.txt
这里的2>是将错误信息输出重定向到/tmp/name.txt文件中。
密码框
格式：
dialog --passwordbox text height width [init]
例子：
$ dialog --title "Password" --passwordbox "Please give a password for the new user:" 10 35
密码暴露出来不安全，所以通常我们会加上一个安全选项--insecure，将每个字符用*来显示。
$ dialog --title "Password" --insecure --passwordbox "Please give a password for the new user:" 10 30
文本框
格式：
dialog --textbox file height width
例子：
$ dialog --title "The fstab" --textbox /etc/fstab 17 40
菜单框
格式：
dialog --menu text height width menu-height tag1 item1 tag2 item2 …
例子：
$ dialog --title "Pick a choice" --menu "Choose one" 12 35 5 1 "say hello to everyone" 2 "thanks for your support" 3 "exit"
Fselect框(文件选框)
格式：
dialog --fselect filepath height width
例子：
$ dialog --title "Pick one file" --fselect /root/ 7 40
复选框
格式：
dialog --checklist "Test" height width menu-height tag1 item1 tag2 item2 …
例子：
$ dialog --backtitle "Checklist" --checklist "Test" 20 50 10 Memory Memory_Size 1 Dsik Disk_Size 2
显示日历
格式：
dialog --calendar "Date" height width day month year
例子：
显示当前日期
$ dialog --title "Calendar" --calendar "Date" 5 50
显示指定日期
$ dialog --title "Calendar" --calendar "Date" 5 50 1 2 2013
进度框架
格式：
dialog --gauge text height width  [<percent>]
例子：
固定进度显示
$ dialog --title "installation pro" --gauge "installation" 10 30 10
实时动度进度
$ for i in {1..100} ;do echo $i;done | dialog --title "installation pro" --gauge "installation" 10 30
编辑一个gauge.sh的脚本，内容如下：
#!/bin/bash  
declare -i PERCENT=0
(
    for I in /etc/*;
    do
        if [ $PERCENT -le 100 ];then
            cp -r $I /tmp/test 2> /dev/null
            echo "XXX" 
            echo "Copy the file $I ..." 
            echo "XXX" 
            echo $PERCENT  
        fi
        let PERCENT+=1
        sleep 0.1
    done
) | dialog --title "coping" --gauge "starting to copy files..." 6 50 0
from框架(表单)
格式：
dialog --form text height width formheight [ label y x item y x flen ilen ] ...
其中：flen表示field length，定义了选定字段中显示的长度；ilen表示input-length, 定义了在外地输入的数据允许的长度。使用up/down（或ctrl/ N，ctrl/ P）在使用领域之间移动，使用tab键在窗口之间切换。
例子：
$ dialog --title "Add a user" --form "Please input the infomation of new user:" 12 40 4 \
  "Username:" 1  1 "" 1  15  15  0 \
  "Full name:" 2  1 "" 2  15  15  0 \
  "Home Dir:" 3  1 "" 3  15  15  0 \
  "Shell:"    4   1 "" 4  15  15  0
补充命令2：zenity
zenity是一个程序，它将显示图形框，并返回（在返回代码中，或在标准输出中）用户的输入。这允许您从各种shell脚本中呈现信息，并向用户索取信息。
语法格式：zenity [参数]
常用参数：
--calendar
	
快速日历对话框
--error
	
错误对话框
--entry
	
一般文本输入对话框
--info
	
信息对话框
--question
	
问题对话框
--progress
	
进度栏
--scale
	
缩放对话框
--password
	
密码对话框
--forms
	
窗体对话框
--about
	
关于对话
参考实例
使用zenity命令显示快速日历对话框：
[root@linuxcool ~]# zenity --calendar
弹框显示进度栏：
[root@linuxcool ~]# zenity --progress
显示密码框：
[root@linuxcool ~]# zenity --password
与该功能相关的Linux命令：

    fgconsole命令 – 显示活动的虚拟终端数量
    systemctl命令 – 管理系统服务
    mountpoint命令 – 判断指定的目录是否是挂载点
    service命令 – 控制系统服务
    supervisord命令 – 配置后台服务/常驻进程的进程工具
    timedatectl命令 – 控制系统时间和日期
    nice命令 – 调整进程的优先级
    passwd命令 – 修改用户账户密码
    iptables-save命令 – 保存iptables的表配置
    XF86Setup命令 – 设置XFee86
